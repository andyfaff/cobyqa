%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage[LGR,T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


\usepackage{dsfont}

% Constants and mathematical functions in Roman style font.
\def\eu{\ensuremath{\mathrm{e}}}
\def\iu{\ensuremath{\mathrm{i}}}
\def\du{\ensuremath{\mathrm{d}}}
\DeclareMathOperator{\vspan}{span}

% Extra mathematical functions
\newcommand{\abs}[2][]{#1\lvert#2#1\rvert}
\newcommand{\ceil}[2][]{#1\lceil#2#1\rceil}
\newcommand{\floor}[2][]{#1\lfloor#2#1\rfloor}
\newcommand{\norm}[2][]{#1\lVert#2#1\rVert}
\newcommand{\set}[2][]{#1\{#2#1\}}
\newcommand{\inner}[2][]{#1\langle#2#1\rangle}

% Sets in blackboard-bold style font.
\def\C{\ensuremath{\mathds{C}}}
\def\N{\ensuremath{\mathds{N}}}
\def\Q{\ensuremath{\mathds{Q}}}
\def\R{\ensuremath{\mathds{R}}}
\def\Z{\ensuremath{\mathds{Z}}}

% Mathematical operators in sans serif style font
\def\T{\ensuremath{\mathsf{T}}}
    

\title{COBYQA User Guide}
\date{October 22, 2021}
\release{1.0.dev0}
\author{Tom M. Ragonneau}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{refs/index::doc}}

\begin{quote}\begin{description}
\item[{Release}] \leavevmode
\sphinxAtStartPar
1.0.dev0

\item[{Date}] \leavevmode
\sphinxAtStartPar
October 22, 2021

\end{description}\end{quote}

\sphinxAtStartPar
This section references an exhaustive manual detailing the functions, modules,
and objects included in COBYQA. For a complete description of the software, see
the \DUrole{xref,std,std-ref}{general documentation}.
\phantomsection\label{\detokenize{refs/optimize:module-cobyqa}}\index{module@\spxentry{module}!cobyqa@\spxentry{cobyqa}}\index{cobyqa@\spxentry{cobyqa}!module@\spxentry{module}}

\chapter{Optimization solver (\sphinxstyleliteralintitle{\sphinxupquote{cobyqa}})}
\label{\detokenize{refs/optimize:optimization-solver-cobyqa}}\label{\detokenize{refs/optimize::doc}}
\sphinxAtStartPar
This module includes the main functions, methods, and objects of COBYQA. Most
users should be contended with the function {\hyperref[\detokenize{refs/generated/cobyqa.minimize:cobyqa.minimize}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cobyqa.minimize}}}}}, being the entry
point of the COBYQA method.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.minimize:cobyqa.minimize}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{minimize}}}}}(fun, x0{[}, args, xl, xu, Aub, bub, ...{]})
&
\sphinxAtStartPar
Minimize a real\sphinxhyphen{}valued function.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult:cobyqa.OptimizeResult}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{OptimizeResult}}}}}
&
\sphinxAtStartPar
Structure for the result of an optimization algorithm.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion:cobyqa.optimize.TrustRegion}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{optimize.TrustRegion}}}}}(fun, x0{[}, args, xl, ...{]})
&
\sphinxAtStartPar
Framework atomization of the derivative\sphinxhyphen{}free trust\sphinxhyphen{}region SQP method.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models:cobyqa.optimize.Models}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{optimize.Models}}}}}(fun, x0, xl, xu, Aub, bub, ...)
&
\sphinxAtStartPar
Model a nonlinear optimization problem.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic:cobyqa.optimize.Quadratic}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{optimize.Quadratic}}}}}(bmat, zmat, idz, fval)
&
\sphinxAtStartPar
Representation of a quadratic multivariate function.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\section{cobyqa.minimize}
\label{\detokenize{refs/generated/cobyqa.minimize:cobyqa-minimize}}\label{\detokenize{refs/generated/cobyqa.minimize::doc}}\index{minimize() (in module cobyqa)@\spxentry{minimize()}\spxextra{in module cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.minimize:cobyqa.minimize}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cobyqa.}}\sphinxbfcode{\sphinxupquote{minimize}}}{\emph{\DUrole{n}{fun}}, \emph{\DUrole{n}{x0}}, \emph{\DUrole{n}{args}\DUrole{o}{=}\DUrole{default_value}{()}}, \emph{\DUrole{n}{xl}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{xu}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{Aub}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{bub}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{Aeq}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{beq}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cub}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ceq}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Minimize a real\sphinxhyphen{}valued function.

\sphinxAtStartPar
The minimization can be subject to bound, linear inequality, linear
equality, nonlinear inequality, and nonlinear equality constraints using a
derivative\sphinxhyphen{}free trust\sphinxhyphen{}region SQP method. Although the solver may tackle
infeasible points (including the initial guess), the bounds constraints (if
any) are always respected.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{fun}}] \leavevmode{[}callable{]}
\sphinxAtStartPar
Objective function to be minimized.
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fun(x, *args) \sphinxhyphen{}> float}}
\end{quote}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{x}} is an array with shape (n,) and \sphinxstyleemphasis{args} is a tuple of
parameters to forward to the objective function.

\item[{\sphinxstylestrong{x0}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Initial guess.

\item[{\sphinxstylestrong{args}}] \leavevmode{[}tuple, optional{]}
\sphinxAtStartPar
Parameters to forward to the objective, the nonlinear inequality
constraint, and the nonlinear equality constraint functions.

\item[{\sphinxstylestrong{xl}}] \leavevmode{[}array\_like, shape (n,), optional{]}
\sphinxAtStartPar
Lower\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{\sphinxhyphen{}numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{xu}}] \leavevmode{[}array\_like, shape (n,), optional{]}
\sphinxAtStartPar
Upper\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{Aub}}] \leavevmode{[}array\_like, shape (mlub, n), optional{]}
\sphinxAtStartPar
Jacobian matrix of the linear inequality constraints. Each row of \sphinxstyleemphasis{Aub}
stores the gradient of a linear inequality constraint.

\item[{\sphinxstylestrong{bub}}] \leavevmode{[}array\_like, shape (mlub,), optional{]}
\sphinxAtStartPar
Right\sphinxhyphen{}hand side vector of the linear inequality constraints
\sphinxcode{\sphinxupquote{Aub @ x <= bub}}, where \sphinxcode{\sphinxupquote{x}} has the same size than \sphinxstyleemphasis{x0}.

\item[{\sphinxstylestrong{Aeq}}] \leavevmode{[}array\_like, shape (mleq, n), optional{]}
\sphinxAtStartPar
Jacobian matrix of the linear equality constraints. Each row of \sphinxstyleemphasis{Aeq}
stores the gradient of a linear equality constraint.

\item[{\sphinxstylestrong{beq}}] \leavevmode{[}array\_like, shape (mleq,), optional{]}
\sphinxAtStartPar
Right\sphinxhyphen{}hand side vector of the linear equality constraints
\sphinxstyleemphasis{Aeq @ x = beq}, where \sphinxcode{\sphinxupquote{x}} has the same size than \sphinxstyleemphasis{x0}.

\item[{\sphinxstylestrong{cub}}] \leavevmode{[}callable{]}
\sphinxAtStartPar
Nonlinear inequality constraint function \sphinxcode{\sphinxupquote{ceq(x, *args) <= 0}}.
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cub(x, *args) \sphinxhyphen{}> array\_like, shape (mnlub,)}}
\end{quote}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{x}} is an array with shape (n,) and \sphinxstyleemphasis{args} is a tuple of
parameters to forward to the constraint function.

\item[{\sphinxstylestrong{ceq}}] \leavevmode{[}callable{]}
\sphinxAtStartPar
Nonlinear equality constraint function \sphinxcode{\sphinxupquote{ceq(x, *args) = 0}}.
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ceq(x, *args) \sphinxhyphen{}> array\_like, shape (mnleq,)}}
\end{quote}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{x}} is an array with shape (n,) and \sphinxstyleemphasis{args} is a tuple of
parameters to forward to the constraint function.

\item[{\sphinxstylestrong{options}}] \leavevmode{[}dict, optional{]}
\sphinxAtStartPar
Options to forward to the solver. Accepted options are:
\begin{quote}
\begin{description}
\item[{rhobeg}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Initial trust\sphinxhyphen{}region radius (the default is 1).

\item[{rhoend}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Final trust\sphinxhyphen{}region radius (the default is 1e\sphinxhyphen{}6).

\item[{npt}] \leavevmode{[}int, optional{]}
\sphinxAtStartPar
Number of interpolation points for the objective and constraint
models (the default is \sphinxcode{\sphinxupquote{2 * n + 1}}).

\item[{maxfev}] \leavevmode{[}int, optional{]}
\sphinxAtStartPar
Upper bound on the number of objective and constraint function
evaluations (the default is \sphinxcode{\sphinxupquote{500 * n}}).

\item[{target}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Target value on the objective function (the default is
\sphinxcode{\sphinxupquote{\sphinxhyphen{}numpy.inf}}). If the solver encounters a feasible point at
which the objective function evaluations is below the target
value, then the computations are stopped.

\item[{disp}] \leavevmode{[}bool, optional{]}
\sphinxAtStartPar
Whether to print pieces of information on the execution of the
solver (the default is False).

\item[{debug}] \leavevmode{[}bool, optional{]}
\sphinxAtStartPar
Whether to make debugging tests during the execution, which is
not recommended in production (the default is False).

\end{description}
\end{quote}

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{OptimizeResult}] \leavevmode
\sphinxAtStartPar
Result of the optimization solver. Important attributes are: \sphinxcode{\sphinxupquote{x}} the
solution point, \sphinxcode{\sphinxupquote{success}} a flag indicating whether the optimization
terminated successfully, and \sphinxcode{\sphinxupquote{message}} a description of the
termination status of the optimization. See {\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult:cobyqa.OptimizeResult}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{OptimizeResult}}}}} for a
description of other attributes.

\end{description}

\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{bdtol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the bound constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * n * max(1, max(abs(xl)), max(abs(xu)))}}, where the values
of \sphinxcode{\sphinxupquote{xl}} and \sphinxcode{\sphinxupquote{xu}} evolve to include the shift of the origin).

\item[{\sphinxstylestrong{lctol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the linear constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * max(mlub, n) * max(1, max(abs(bub)))}}, where the values
of \sphinxcode{\sphinxupquote{bub}} evolve to include the shift of the origin).

\item[{\sphinxstylestrong{lstol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance on the approximate KKT conditions for the calculations of the
least\sphinxhyphen{}squares Lagrange multipliers (the default is
\sphinxcode{\sphinxupquote{10 * eps * max(n, m) * max(1, max(abs(g)))}}, where \sphinxcode{\sphinxupquote{g}} is the
gradient of the current model of the objective function).

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\section{cobyqa.OptimizeResult}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult:cobyqa-optimizeresult}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult::doc}}\index{OptimizeResult (class in cobyqa)@\spxentry{OptimizeResult}\spxextra{class in cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult:cobyqa.OptimizeResult}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{cobyqa.}}\sphinxbfcode{\sphinxupquote{OptimizeResult}}}
\sphinxAtStartPar
Structure for the result of an optimization algorithm.
\begin{quote}\begin{description}
\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Solution point provided by the optimization solver.

\item[{\sphinxstylestrong{success}}] \leavevmode{[}bool{]}
\sphinxAtStartPar
Flag indicating whether the optimization solver terminated successfully.

\item[{\sphinxstylestrong{status}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Termination status of the optimization solver.

\item[{\sphinxstylestrong{message}}] \leavevmode{[}str{]}
\sphinxAtStartPar
Description of the termination status of the optimization solver.

\item[{\sphinxstylestrong{fun}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Value of the objective function at the solution point provided by the
optimization solver.

\item[{\sphinxstylestrong{jac}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Approximation of the gradient of the objective function at the solution
point provided by the optimization solver, based on undetermined
interpolation. If the value of a component (or more) of the gradient is
unknown, it is replaced by \sphinxcode{\sphinxupquote{numpy.nan}}.

\item[{\sphinxstylestrong{nfev}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Number of objective and constraint function evaluations.

\item[{\sphinxstylestrong{nit}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Number of iterations performed by the optimization solver.

\item[{\sphinxstylestrong{maxcv}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Maximum constraint violation at the solution point provided by the
optimization solver. It is set only if the problem is not declared
unconstrained by the optimization solver.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult.clear:cobyqa.OptimizeResult.clear}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{clear}}}}}()
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult.copy:cobyqa.OptimizeResult.copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{copy}}}}}()
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult.fromkeys:cobyqa.OptimizeResult.fromkeys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fromkeys}}}}}(iterable{[}, value{]})
&
\sphinxAtStartPar
Create a new dictionary with keys from iterable and values set to value.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult.get:cobyqa.OptimizeResult.get}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get}}}}}(key{[}, default{]})
&
\sphinxAtStartPar
Return the value for key if key is in the dictionary, else default.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult.items:cobyqa.OptimizeResult.items}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{items}}}}}()
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult.keys:cobyqa.OptimizeResult.keys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{keys}}}}}()
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult.pop:cobyqa.OptimizeResult.pop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pop}}}}}(key{[}, default{]})
&
\sphinxAtStartPar
If key is not found, default is returned if given, otherwise KeyError is raised
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult.popitem:cobyqa.OptimizeResult.popitem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{popitem}}}}}(/)
&
\sphinxAtStartPar
Remove and return a (key, value) pair as a 2\sphinxhyphen{}tuple.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult.setdefault:cobyqa.OptimizeResult.setdefault}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{setdefault}}}}}(key{[}, default{]})
&
\sphinxAtStartPar
Insert key with a value of default if key is not in the dictionary.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult.update:cobyqa.OptimizeResult.update}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update}}}}}({[}E, {]}**F)
&
\sphinxAtStartPar
If E is present and has a .keys() method, then does:  for k in E: D{[}k{]} = E{[}k{]} If E is present and lacks a .keys() method, then does:  for k, v in E: D{[}k{]} = v In either case, this is followed by: for k in F:  D{[}k{]} = F{[}k{]}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.OptimizeResult.values:cobyqa.OptimizeResult.values}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{values}}}}}()
&
\sphinxAtStartPar

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsection{cobyqa.OptimizeResult.clear}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult.clear:cobyqa-optimizeresult-clear}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult.clear::doc}}
\sphinxAtStartPar
method
\index{clear() (cobyqa.OptimizeResult method)@\spxentry{clear()}\spxextra{cobyqa.OptimizeResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult.clear:cobyqa.OptimizeResult.clear}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{OptimizeResult.}}\sphinxbfcode{\sphinxupquote{clear}}}{}{{ $\rightarrow$ None.  Remove all items from D.}}~
\end{fulllineitems}



\subsection{cobyqa.OptimizeResult.copy}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult.copy:cobyqa-optimizeresult-copy}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult.copy::doc}}
\sphinxAtStartPar
method
\index{copy() (cobyqa.OptimizeResult method)@\spxentry{copy()}\spxextra{cobyqa.OptimizeResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult.copy:cobyqa.OptimizeResult.copy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{OptimizeResult.}}\sphinxbfcode{\sphinxupquote{copy}}}{}{{ $\rightarrow$ a shallow copy of D}}~
\end{fulllineitems}



\subsection{cobyqa.OptimizeResult.fromkeys}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult.fromkeys:cobyqa-optimizeresult-fromkeys}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult.fromkeys::doc}}
\sphinxAtStartPar
method
\index{fromkeys() (cobyqa.OptimizeResult method)@\spxentry{fromkeys()}\spxextra{cobyqa.OptimizeResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult.fromkeys:cobyqa.OptimizeResult.fromkeys}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{OptimizeResult.}}\sphinxbfcode{\sphinxupquote{fromkeys}}}{\emph{\DUrole{n}{iterable}}, \emph{\DUrole{n}{value}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{/}}}{}
\sphinxAtStartPar
Create a new dictionary with keys from iterable and values set to value.

\end{fulllineitems}



\subsection{cobyqa.OptimizeResult.get}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult.get:cobyqa-optimizeresult-get}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult.get::doc}}
\sphinxAtStartPar
method
\index{get() (cobyqa.OptimizeResult method)@\spxentry{get()}\spxextra{cobyqa.OptimizeResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult.get:cobyqa.OptimizeResult.get}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{OptimizeResult.}}\sphinxbfcode{\sphinxupquote{get}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{/}}}{}
\sphinxAtStartPar
Return the value for key if key is in the dictionary, else default.

\end{fulllineitems}



\subsection{cobyqa.OptimizeResult.items}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult.items:cobyqa-optimizeresult-items}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult.items::doc}}
\sphinxAtStartPar
method
\index{items() (cobyqa.OptimizeResult method)@\spxentry{items()}\spxextra{cobyqa.OptimizeResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult.items:cobyqa.OptimizeResult.items}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{OptimizeResult.}}\sphinxbfcode{\sphinxupquote{items}}}{}{{ $\rightarrow$ a set\sphinxhyphen{}like object providing a view on D's items}}~
\end{fulllineitems}



\subsection{cobyqa.OptimizeResult.keys}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult.keys:cobyqa-optimizeresult-keys}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult.keys::doc}}
\sphinxAtStartPar
method
\index{keys() (cobyqa.OptimizeResult method)@\spxentry{keys()}\spxextra{cobyqa.OptimizeResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult.keys:cobyqa.OptimizeResult.keys}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{OptimizeResult.}}\sphinxbfcode{\sphinxupquote{keys}}}{}{{ $\rightarrow$ a set\sphinxhyphen{}like object providing a view on D's keys}}~
\end{fulllineitems}



\subsection{cobyqa.OptimizeResult.pop}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult.pop:cobyqa-optimizeresult-pop}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult.pop::doc}}
\sphinxAtStartPar
method
\index{pop() (cobyqa.OptimizeResult method)@\spxentry{pop()}\spxextra{cobyqa.OptimizeResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult.pop:cobyqa.OptimizeResult.pop}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{OptimizeResult.}}\sphinxbfcode{\sphinxupquote{pop}}}{\emph{key}, \emph{default=<unrepresentable>}, \emph{/}}{}
\sphinxAtStartPar
If key is not found, default is returned if given, otherwise KeyError is raised

\end{fulllineitems}



\subsection{cobyqa.OptimizeResult.popitem}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult.popitem:cobyqa-optimizeresult-popitem}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult.popitem::doc}}
\sphinxAtStartPar
method
\index{popitem() (cobyqa.OptimizeResult method)@\spxentry{popitem()}\spxextra{cobyqa.OptimizeResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult.popitem:cobyqa.OptimizeResult.popitem}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{OptimizeResult.}}\sphinxbfcode{\sphinxupquote{popitem}}}{\emph{/}}{}
\sphinxAtStartPar
Remove and return a (key, value) pair as a 2\sphinxhyphen{}tuple.

\sphinxAtStartPar
Pairs are returned in LIFO (last\sphinxhyphen{}in, first\sphinxhyphen{}out) order.
Raises KeyError if the dict is empty.

\end{fulllineitems}



\subsection{cobyqa.OptimizeResult.setdefault}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult.setdefault:cobyqa-optimizeresult-setdefault}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult.setdefault::doc}}
\sphinxAtStartPar
method
\index{setdefault() (cobyqa.OptimizeResult method)@\spxentry{setdefault()}\spxextra{cobyqa.OptimizeResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult.setdefault:cobyqa.OptimizeResult.setdefault}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{OptimizeResult.}}\sphinxbfcode{\sphinxupquote{setdefault}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{/}}}{}
\sphinxAtStartPar
Insert key with a value of default if key is not in the dictionary.

\sphinxAtStartPar
Return the value for key if key is in the dictionary, else default.

\end{fulllineitems}



\subsection{cobyqa.OptimizeResult.update}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult.update:cobyqa-optimizeresult-update}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult.update::doc}}
\sphinxAtStartPar
method
\index{update() (cobyqa.OptimizeResult method)@\spxentry{update()}\spxextra{cobyqa.OptimizeResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult.update:cobyqa.OptimizeResult.update}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{OptimizeResult.}}\sphinxbfcode{\sphinxupquote{update}}}{\sphinxoptional{\emph{E}}, \emph{**F}}{{ $\rightarrow$ None.  Update D from dict/iterable E and F.}}
\sphinxAtStartPar
If E is present and has a .keys() method, then does:  for k in E: D{[}k{]} = E{[}k{]}
If E is present and lacks a .keys() method, then does:  for k, v in E: D{[}k{]} = v
In either case, this is followed by: for k in F:  D{[}k{]} = F{[}k{]}

\end{fulllineitems}



\subsection{cobyqa.OptimizeResult.values}
\label{\detokenize{refs/generated/cobyqa.OptimizeResult.values:cobyqa-optimizeresult-values}}\label{\detokenize{refs/generated/cobyqa.OptimizeResult.values::doc}}
\sphinxAtStartPar
method
\index{values() (cobyqa.OptimizeResult method)@\spxentry{values()}\spxextra{cobyqa.OptimizeResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.OptimizeResult.values:cobyqa.OptimizeResult.values}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{OptimizeResult.}}\sphinxbfcode{\sphinxupquote{values}}}{}{{ $\rightarrow$ an object providing a view on D's values}}~
\end{fulllineitems}


\end{fulllineitems}



\section{cobyqa.optimize.TrustRegion}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion:cobyqa-optimize-trustregion}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion::doc}}\index{TrustRegion (class in cobyqa.optimize)@\spxentry{TrustRegion}\spxextra{class in cobyqa.optimize}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion:cobyqa.optimize.TrustRegion}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{cobyqa.optimize.}}\sphinxbfcode{\sphinxupquote{TrustRegion}}}{\emph{\DUrole{n}{fun}}, \emph{\DUrole{n}{x0}}, \emph{\DUrole{n}{args}\DUrole{o}{=}\DUrole{default_value}{()}}, \emph{\DUrole{n}{xl}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{xu}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{Aub}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{bub}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{Aeq}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{beq}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cub}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ceq}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Framework atomization of the derivative\sphinxhyphen{}free trust\sphinxhyphen{}region SQP method.
\begin{quote}\begin{description}
\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxcode{\sphinxupquote{aeq}}}] \leavevmode
\sphinxAtStartPar
Jacobian matrix of the normalized linear equality constraints.

\item[{\sphinxcode{\sphinxupquote{aub}}}] \leavevmode
\sphinxAtStartPar
Jacobian matrix of the normalized linear inequality constraints.

\item[{\sphinxcode{\sphinxupquote{beq}}}] \leavevmode
\sphinxAtStartPar
Right\sphinxhyphen{}hand side vector of the normalized linear equality constraints.

\item[{\sphinxcode{\sphinxupquote{bub}}}] \leavevmode
\sphinxAtStartPar
Right\sphinxhyphen{}hand side vector of the normalized linear inequality constraints.

\item[{\sphinxcode{\sphinxupquote{copteq}}}] \leavevmode
\sphinxAtStartPar
Evaluation of the nonlinear equality constraint function of the nonlinear optimization problem at \sphinxcode{\sphinxupquote{xopt}}.

\item[{\sphinxcode{\sphinxupquote{coptub}}}] \leavevmode
\sphinxAtStartPar
Evaluation of the nonlinear inequality constraint function of the nonlinear optimization problem at \sphinxcode{\sphinxupquote{xopt}}.

\item[{\sphinxcode{\sphinxupquote{cvaleq}}}] \leavevmode
\sphinxAtStartPar
Evaluations of the nonlinear equality constraint function of the nonlinear optimization problem at the interpolation points.

\item[{\sphinxcode{\sphinxupquote{cvalub}}}] \leavevmode
\sphinxAtStartPar
Evaluations of the nonlinear inequality constraint function of the nonlinear optimization problem at the interpolation points.

\item[{\sphinxcode{\sphinxupquote{fopt}}}] \leavevmode
\sphinxAtStartPar
Evaluation of the objective function of the nonlinear optimization problem at \sphinxcode{\sphinxupquote{xopt}}.

\item[{\sphinxcode{\sphinxupquote{fval}}}] \leavevmode
\sphinxAtStartPar
Evaluations of the objective function of the nonlinear optimization problem at the interpolation points.

\item[{\sphinxcode{\sphinxupquote{ifix}}}] \leavevmode
\sphinxAtStartPar
Indices of the fixed variables.

\item[{\sphinxcode{\sphinxupquote{is\_model\_step}}}] \leavevmode
\sphinxAtStartPar
Flag indicating whether the current step is a model step.

\item[{\sphinxcode{\sphinxupquote{knew}}}] \leavevmode
\sphinxAtStartPar
Index of the interpolation point to be removed from the interpolation set.

\item[{\sphinxcode{\sphinxupquote{kopt}}}] \leavevmode
\sphinxAtStartPar
Index of the best interpolation point so far, corresponding to the point around which the Taylor expansions of the quadratic models are defined.

\item[{\sphinxcode{\sphinxupquote{lmleq}}}] \leavevmode
\sphinxAtStartPar
Lagrange multipliers associated with the linear equality constraints.

\item[{\sphinxcode{\sphinxupquote{lmlub}}}] \leavevmode
\sphinxAtStartPar
Lagrange multipliers associated with the linear inequality constraints.

\item[{\sphinxcode{\sphinxupquote{lmnleq}}}] \leavevmode
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the nonlinear equality constraints.

\item[{\sphinxcode{\sphinxupquote{lmnlub}}}] \leavevmode
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the nonlinear inequality constraints.

\item[{\sphinxcode{\sphinxupquote{maxcv}}}] \leavevmode
\sphinxAtStartPar
Constraint violation evaluated on the nonlinear optimization problem at t`xopt`.

\item[{\sphinxcode{\sphinxupquote{mleq}}}] \leavevmode
\sphinxAtStartPar
Number of the linear equality constraints.

\item[{\sphinxcode{\sphinxupquote{mlub}}}] \leavevmode
\sphinxAtStartPar
Number of the linear inequality constraints.

\item[{\sphinxcode{\sphinxupquote{mnleq}}}] \leavevmode
\sphinxAtStartPar
Number of the nonlinear equality constraints.

\item[{\sphinxcode{\sphinxupquote{mnlub}}}] \leavevmode
\sphinxAtStartPar
Number of the nonlinear inequality constraints.

\item[{\sphinxcode{\sphinxupquote{options}}}] \leavevmode
\sphinxAtStartPar
Options forwarded to the solver.

\item[{\sphinxcode{\sphinxupquote{peneq}}}] \leavevmode
\sphinxAtStartPar
Penalty coefficient associated with the equality constraints.

\item[{\sphinxcode{\sphinxupquote{penub}}}] \leavevmode
\sphinxAtStartPar
Penalty coefficient associated with the inequality constraints.

\item[{\sphinxcode{\sphinxupquote{rval}}}] \leavevmode
\sphinxAtStartPar
Residuals associated with the constraints of the nonlinear optimization problem at the interpolation points.

\item[{\sphinxcode{\sphinxupquote{target\_reached}}}] \leavevmode
\sphinxAtStartPar
Indicate whether the computations have been stopped because the target value has been reached.

\item[{\sphinxcode{\sphinxupquote{type}}}] \leavevmode
\sphinxAtStartPar
Type of the nonlinear optimization problem.

\item[{\sphinxcode{\sphinxupquote{xbase}}}] \leavevmode
\sphinxAtStartPar
Shift of the origin in the calculations.

\item[{\sphinxcode{\sphinxupquote{xfix}}}] \leavevmode
\sphinxAtStartPar
Values of the fixed variables.

\item[{\sphinxcode{\sphinxupquote{xl}}}] \leavevmode
\sphinxAtStartPar
Lower\sphinxhyphen{}bound constraints on the decision variables.

\item[{\sphinxcode{\sphinxupquote{xopt}}}] \leavevmode
\sphinxAtStartPar
Best interpolation point so far, corresponding to the point around which the Taylor expansion of the quadratic models are defined.

\item[{\sphinxcode{\sphinxupquote{xpt}}}] \leavevmode
\sphinxAtStartPar
Displacements of the interpolation points from the origin.

\item[{\sphinxcode{\sphinxupquote{xu}}}] \leavevmode
\sphinxAtStartPar
Upper\sphinxhyphen{}bound constraints on the decision variables.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.__call__:cobyqa.optimize.TrustRegion.__call__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_call\_\_}}}}}(x, fx, cubx, ceqx{[}, model{]})
&
\sphinxAtStartPar
Evaluate the merit function.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.ceq:cobyqa.optimize.TrustRegion.ceq}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ceq}}}}}(x)
&
\sphinxAtStartPar
Evaluate the nonlinear equality constraint function of the nonlinear optimization problem.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.check_models:cobyqa.optimize.TrustRegion.check_models}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{check\_models}}}}}({[}stack\_level{]})
&
\sphinxAtStartPar
Check the interpolation conditions.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.check_options:cobyqa.optimize.TrustRegion.check_options}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{check\_options}}}}}(n{[}, stack\_level{]})
&
\sphinxAtStartPar
Ensure that the options are consistent, and modify them if necessary.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.cub:cobyqa.optimize.TrustRegion.cub}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cub}}}}}(x)
&
\sphinxAtStartPar
Evaluate the nonlinear inequality constraint function of the nonlinear optimization problem.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.fun:cobyqa.optimize.TrustRegion.fun}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fun}}}}}(x)
&
\sphinxAtStartPar
Evaluate the objective function of the nonlinear optimization problem.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.get_best_point:cobyqa.optimize.TrustRegion.get_best_point}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_best\_point}}}}}()
&
\sphinxAtStartPar
Get the index of the optimal interpolation point.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.get_x:cobyqa.optimize.TrustRegion.get_x}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_x}}}}}(x)
&
\sphinxAtStartPar
Build the full decision variables.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.less_merit:cobyqa.optimize.TrustRegion.less_merit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{less\_merit}}}}}(mval1, rval1, mval2, rval2)
&
\sphinxAtStartPar
Indicates whether a point is better than another.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq:cobyqa.optimize.TrustRegion.model_ceq}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_ceq}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate an equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt:cobyqa.optimize.TrustRegion.model_ceq_alt}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_ceq\_alt}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate an alternative equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_curv:cobyqa.optimize.TrustRegion.model_ceq_alt_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_ceq\_alt\_curv}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the curvature of an alternative equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_grad:cobyqa.optimize.TrustRegion.model_ceq_alt_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_ceq\_alt\_grad}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the gradient of an alternative equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_hess:cobyqa.optimize.TrustRegion.model_ceq_alt_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_ceq\_alt\_hess}}}}}(i)
&
\sphinxAtStartPar
Evaluate the Hessian matrix of an alternative equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_hessp:cobyqa.optimize.TrustRegion.model_ceq_alt_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_ceq\_alt\_hessp}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an alternative equality constraint function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_curv:cobyqa.optimize.TrustRegion.model_ceq_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_ceq\_curv}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the curvature of an equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_grad:cobyqa.optimize.TrustRegion.model_ceq_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_ceq\_grad}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the gradient of an equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_hess:cobyqa.optimize.TrustRegion.model_ceq_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_ceq\_hess}}}}}(i)
&
\sphinxAtStartPar
Evaluate the Hessian matrix of an equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_hessp:cobyqa.optimize.TrustRegion.model_ceq_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_ceq\_hessp}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an equality constraint function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub:cobyqa.optimize.TrustRegion.model_cub}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_cub}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate an inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt:cobyqa.optimize.TrustRegion.model_cub_alt}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_cub\_alt}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate an alternative inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_curv:cobyqa.optimize.TrustRegion.model_cub_alt_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_cub\_alt\_curv}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the curvature of an alternative inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_grad:cobyqa.optimize.TrustRegion.model_cub_alt_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_cub\_alt\_grad}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the gradient of an alternative inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_hess:cobyqa.optimize.TrustRegion.model_cub_alt_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_cub\_alt\_hess}}}}}(i)
&
\sphinxAtStartPar
Evaluate the Hessian matrix of an alternative inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_hessp:cobyqa.optimize.TrustRegion.model_cub_alt_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_cub\_alt\_hessp}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an alternative inequality constraint function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_curv:cobyqa.optimize.TrustRegion.model_cub_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_cub\_curv}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the curvature of an inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_grad:cobyqa.optimize.TrustRegion.model_cub_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_cub\_grad}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the gradient of an inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_hess:cobyqa.optimize.TrustRegion.model_cub_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_cub\_hess}}}}}(i)
&
\sphinxAtStartPar
Evaluate the Hessian matrix of an inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_hessp:cobyqa.optimize.TrustRegion.model_cub_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_cub\_hessp}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an inequality constraint function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag:cobyqa.optimize.TrustRegion.model_lag}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_lag}}}}}(x)
&
\sphinxAtStartPar
Evaluate the Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt:cobyqa.optimize.TrustRegion.model_lag_alt}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_lag\_alt}}}}}(x)
&
\sphinxAtStartPar
Evaluate the alternative Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_curv:cobyqa.optimize.TrustRegion.model_lag_alt_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_lag\_alt\_curv}}}}}(x)
&
\sphinxAtStartPar
Evaluate the curvature of the alternative Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_grad:cobyqa.optimize.TrustRegion.model_lag_alt_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_lag\_alt\_grad}}}}}(x)
&
\sphinxAtStartPar
Evaluate the gradient of the alternative Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_hess:cobyqa.optimize.TrustRegion.model_lag_alt_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_lag\_alt\_hess}}}}}()
&
\sphinxAtStartPar
Evaluate the Hessian matrix of the alternative Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_hessp:cobyqa.optimize.TrustRegion.model_lag_alt_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_lag\_alt\_hessp}}}}}(x)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the alternative Lagrangian function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_curv:cobyqa.optimize.TrustRegion.model_lag_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_lag\_curv}}}}}(x)
&
\sphinxAtStartPar
Evaluate the curvature of the Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_grad:cobyqa.optimize.TrustRegion.model_lag_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_lag\_grad}}}}}(x)
&
\sphinxAtStartPar
Evaluate the gradient of Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_hess:cobyqa.optimize.TrustRegion.model_lag_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_lag\_hess}}}}}()
&
\sphinxAtStartPar
Evaluate the Hessian matrix of the Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_hessp:cobyqa.optimize.TrustRegion.model_lag_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_lag\_hessp}}}}}(x)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the Lagrangian function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj:cobyqa.optimize.TrustRegion.model_obj}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_obj}}}}}(x)
&
\sphinxAtStartPar
Evaluate the objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt:cobyqa.optimize.TrustRegion.model_obj_alt}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_obj\_alt}}}}}(x)
&
\sphinxAtStartPar
Evaluate the alternative objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_curv:cobyqa.optimize.TrustRegion.model_obj_alt_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_obj\_alt\_curv}}}}}(x)
&
\sphinxAtStartPar
Evaluate the curvature of the alternative objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_grad:cobyqa.optimize.TrustRegion.model_obj_alt_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_obj\_alt\_grad}}}}}(x)
&
\sphinxAtStartPar
Evaluate the gradient of the alternative objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_hess:cobyqa.optimize.TrustRegion.model_obj_alt_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_obj\_alt\_hess}}}}}()
&
\sphinxAtStartPar
Evaluate the Hessian matrix of the alternative objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_hessp:cobyqa.optimize.TrustRegion.model_obj_alt_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_obj\_alt\_hessp}}}}}(x)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the alternative objective function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_curv:cobyqa.optimize.TrustRegion.model_obj_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_obj\_curv}}}}}(x)
&
\sphinxAtStartPar
Evaluate the curvature of the objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_grad:cobyqa.optimize.TrustRegion.model_obj_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_obj\_grad}}}}}(x)
&
\sphinxAtStartPar
Evaluate the gradient of the objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_hess:cobyqa.optimize.TrustRegion.model_obj_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_obj\_hess}}}}}()
&
\sphinxAtStartPar
Evaluate the Hessian matrix of the objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_hessp:cobyqa.optimize.TrustRegion.model_obj_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_obj\_hessp}}}}}(x)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the objective function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_step:cobyqa.optimize.TrustRegion.model_step}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{model\_step}}}}}(delta, **kwargs)
&
\sphinxAtStartPar
Estimate a model\sphinxhyphen{}improvement step from \sphinxcode{\sphinxupquote{xopt}}.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.prepare_model_step:cobyqa.optimize.TrustRegion.prepare_model_step}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{prepare\_model\_step}}}}}(delta)
&
\sphinxAtStartPar
Set the next iteration to a model\sphinxhyphen{}step if necessary.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.prepare_trust_region_step:cobyqa.optimize.TrustRegion.prepare_trust_region_step}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{prepare\_trust\_region\_step}}}}}()
&
\sphinxAtStartPar
Set the next iteration to a trust\sphinxhyphen{}region step.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.reduce_penalty_coefficients:cobyqa.optimize.TrustRegion.reduce_penalty_coefficients}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{reduce\_penalty\_coefficients}}}}}()
&
\sphinxAtStartPar
Reduce the penalty coefficients if possible, to prevent overflows.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.reset_models:cobyqa.optimize.TrustRegion.reset_models}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{reset\_models}}}}}()
&
\sphinxAtStartPar
Reset the models.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.set_default_options:cobyqa.optimize.TrustRegion.set_default_options}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_default\_options}}}}}(n)
&
\sphinxAtStartPar
Set the default options for the solvers.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.shift_origin:cobyqa.optimize.TrustRegion.shift_origin}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{shift\_origin}}}}}(delta)
&
\sphinxAtStartPar
Shift the origin of the calculations if necessary.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.trust_region_step:cobyqa.optimize.TrustRegion.trust_region_step}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{trust\_region\_step}}}}}(delta, **kwargs)
&
\sphinxAtStartPar
Evaluate a Byrd\sphinxhyphen{}Omojokun\sphinxhyphen{}like trust\sphinxhyphen{}region step from \sphinxcode{\sphinxupquote{xopt}}.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update:cobyqa.optimize.TrustRegion.update}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update}}}}}(step, **kwargs)
&
\sphinxAtStartPar
Include a new point in the interpolation set.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update_multipliers:cobyqa.optimize.TrustRegion.update_multipliers}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update\_multipliers}}}}}(**kwargs)
&
\sphinxAtStartPar
Set the least\sphinxhyphen{}squares Lagrange multipliers.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update_penalty_parameters:cobyqa.optimize.TrustRegion.update_penalty_parameters}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update\_penalty\_parameters}}}}}(step, fx, cubx, ceqx)
&
\sphinxAtStartPar
Increase the penalty coefficients.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsection{cobyqa.optimize.TrustRegion.\_\_call\_\_}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.__call__:cobyqa-optimize-trustregion-call}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.__call__::doc}}
\sphinxAtStartPar
method
\index{\_\_call\_\_() (cobyqa.optimize.TrustRegion method)@\spxentry{\_\_call\_\_()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.__call__:cobyqa.optimize.TrustRegion.__call__}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{\_\_call\_\_}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{fx}}, \emph{\DUrole{n}{cubx}}, \emph{\DUrole{n}{ceqx}}, \emph{\DUrole{n}{model}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Evaluate the merit function.

\sphinxAtStartPar
The merit function is an augmented Lagrangian.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the merit function is to be evaluated.

\item[{\sphinxstylestrong{fx}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Value of the objective function at \sphinxstyleemphasis{x}.

\item[{\sphinxstylestrong{cubx}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Value of the nonlinear inequality constraint function at \sphinxstyleemphasis{x}.

\item[{\sphinxstylestrong{ceqx}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Value of the nonlinear equality constraint function at \sphinxstyleemphasis{x}.

\item[{\sphinxstylestrong{model}}] \leavevmode{[}bool, optional{]}
\sphinxAtStartPar
Whether to also evaluate the merit function on the different models
(the default is False).

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float or (float, float)}] \leavevmode
\sphinxAtStartPar
Value of the merit function at \sphinxstyleemphasis{x}, evaluated on the nonlinear
optimization problem. If \sphinxcode{\sphinxupquote{model = True}}, the merit function
evaluated on the different models is also returned.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.ceq}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.ceq:cobyqa-optimize-trustregion-ceq}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.ceq::doc}}
\sphinxAtStartPar
method
\index{ceq() (cobyqa.optimize.TrustRegion method)@\spxentry{ceq()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.ceq:cobyqa.optimize.TrustRegion.ceq}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{ceq}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the nonlinear equality constraint function of the nonlinear
optimization problem.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Point at which the constraint function is to be evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (mnleq,)}] \leavevmode
\sphinxAtStartPar
Value of the nonlinear equality constraint function of the
nonlinear optimization problem at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.check\_models}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.check_models:cobyqa-optimize-trustregion-check-models}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.check_models::doc}}
\sphinxAtStartPar
method
\index{check\_models() (cobyqa.optimize.TrustRegion method)@\spxentry{check\_models()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.check_models:cobyqa.optimize.TrustRegion.check_models}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{check\_models}}}{\emph{\DUrole{n}{stack\_level}\DUrole{o}{=}\DUrole{default_value}{2}}}{}
\sphinxAtStartPar
Check the interpolation conditions.

\sphinxAtStartPar
The method checks whether the evaluations of the quadratic models at the
interpolation points match their expected values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{stack\_level}}] \leavevmode{[}int, optional{]}
\sphinxAtStartPar
Stack level of the warning (the default is 2).

\end{description}

\item[{Warns}] \leavevmode\begin{description}
\item[{RuntimeWarning}] \leavevmode
\sphinxAtStartPar
The evaluations of a quadratic function do not satisfy the
interpolation conditions up to a certain tolerance.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.check\_options}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.check_options:cobyqa-optimize-trustregion-check-options}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.check_options::doc}}
\sphinxAtStartPar
method
\index{check\_options() (cobyqa.optimize.TrustRegion method)@\spxentry{check\_options()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.check_options:cobyqa.optimize.TrustRegion.check_options}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{check\_options}}}{\emph{\DUrole{n}{n}}, \emph{\DUrole{n}{stack\_level}\DUrole{o}{=}\DUrole{default_value}{2}}}{}
\sphinxAtStartPar
Ensure that the options are consistent, and modify them if necessary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{n}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Number of decision variables.

\item[{\sphinxstylestrong{stack\_level}}] \leavevmode{[}int, optional{]}
\sphinxAtStartPar
Stack level of the warning (the default is 2).

\end{description}

\item[{Warns}] \leavevmode\begin{description}
\item[{RuntimeWarning}] \leavevmode
\sphinxAtStartPar
The options are inconsistent and modified.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.cub}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.cub:cobyqa-optimize-trustregion-cub}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.cub::doc}}
\sphinxAtStartPar
method
\index{cub() (cobyqa.optimize.TrustRegion method)@\spxentry{cub()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.cub:cobyqa.optimize.TrustRegion.cub}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{cub}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the nonlinear inequality constraint function of the nonlinear
optimization problem.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Point at which the constraint function is to be evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (mnlub,)}] \leavevmode
\sphinxAtStartPar
Value of the nonlinear inequality constraint function of the
nonlinear optimization problem at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.fun}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.fun:cobyqa-optimize-trustregion-fun}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.fun::doc}}
\sphinxAtStartPar
method
\index{fun() (cobyqa.optimize.TrustRegion method)@\spxentry{fun()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.fun:cobyqa.optimize.TrustRegion.fun}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{fun}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the objective function of the nonlinear optimization problem.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Point at which the objective function is to be evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the objective function of the nonlinear optimization
problem at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.get\_best\_point}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.get_best_point:cobyqa-optimize-trustregion-get-best-point}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.get_best_point::doc}}
\sphinxAtStartPar
method
\index{get\_best\_point() (cobyqa.optimize.TrustRegion method)@\spxentry{get\_best\_point()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.get_best_point:cobyqa.optimize.TrustRegion.get_best_point}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{get\_best\_point}}}{}{}
\sphinxAtStartPar
Get the index of the optimal interpolation point.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode\begin{description}
\item[{int}] \leavevmode
\sphinxAtStartPar
Index of the optimal interpolation point.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.get\_x}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.get_x:cobyqa-optimize-trustregion-get-x}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.get_x::doc}}
\sphinxAtStartPar
method
\index{get\_x() (cobyqa.optimize.TrustRegion method)@\spxentry{get\_x()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.get_x:cobyqa.optimize.TrustRegion.get_x}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{get\_x}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Build the full decision variables.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
The reduced vector of decision variables.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n + m,)}] \leavevmode
\sphinxAtStartPar
All decision variables, included the fixed ones.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.less\_merit}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.less_merit:cobyqa-optimize-trustregion-less-merit}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.less_merit::doc}}
\sphinxAtStartPar
method
\index{less\_merit() (cobyqa.optimize.TrustRegion method)@\spxentry{less\_merit()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.less_merit:cobyqa.optimize.TrustRegion.less_merit}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{less\_merit}}}{\emph{\DUrole{n}{mval1}}, \emph{\DUrole{n}{rval1}}, \emph{\DUrole{n}{mval2}}, \emph{\DUrole{n}{rval2}}}{}
\sphinxAtStartPar
Indicates whether a point is better than another.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{mval1}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Merit value associated with the first point.

\item[{\sphinxstylestrong{rval1}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Residual value associated with the first point.

\item[{\sphinxstylestrong{mval2}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Merit value associated with the second point.

\item[{\sphinxstylestrong{rval2}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Residual value associated with the second point.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{bool}] \leavevmode
\sphinxAtStartPar
A flag indicating whether the first point is better than the other.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_ceq}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq:cobyqa-optimize-trustregion-model-ceq}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq::doc}}
\sphinxAtStartPar
method
\index{model\_ceq() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_ceq()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq:cobyqa.optimize.TrustRegion.model_ceq}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_ceq}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate an equality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the \sphinxstyleemphasis{i}\sphinxhyphen{}th equality constraint function of the model at
\sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_ceq\_alt}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt:cobyqa-optimize-trustregion-model-ceq-alt}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt::doc}}
\sphinxAtStartPar
method
\index{model\_ceq\_alt() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_ceq\_alt()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt:cobyqa.optimize.TrustRegion.model_ceq_alt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_ceq\_alt}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate an alternative equality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative equality constraint function of the
model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_ceq\_alt\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_curv:cobyqa-optimize-trustregion-model-ceq-alt-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_curv::doc}}
\sphinxAtStartPar
method
\index{model\_ceq\_alt\_curv() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_ceq\_alt\_curv()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_curv:cobyqa.optimize.TrustRegion.model_ceq_alt_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_ceq\_alt\_curv}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the curvature of an alternative equality constraint function of
the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative equality constraint function of
the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_ceq\_alt\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_grad:cobyqa-optimize-trustregion-model-ceq-alt-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_grad::doc}}
\sphinxAtStartPar
method
\index{model\_ceq\_alt\_grad() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_ceq\_alt\_grad()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_grad:cobyqa.optimize.TrustRegion.model_ceq_alt_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_ceq\_alt\_grad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the gradient of an alternative equality constraint function of
the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative equality constraint function of
the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_ceq\_alt\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_hess:cobyqa-optimize-trustregion-model-ceq-alt-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_hess::doc}}
\sphinxAtStartPar
method
\index{model\_ceq\_alt\_hess() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_ceq\_alt\_hess()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_hess:cobyqa.optimize.TrustRegion.model_ceq_alt_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_ceq\_alt\_hess}}}{\emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of an alternative equality constraint
function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative equality constraint
function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_ceq\_alt\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_hessp:cobyqa-optimize-trustregion-model-ceq-alt-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_hessp::doc}}
\sphinxAtStartPar
method
\index{model\_ceq\_alt\_hessp() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_ceq\_alt\_hessp()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_alt_hessp:cobyqa.optimize.TrustRegion.model_ceq_alt_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_ceq\_alt\_hessp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an alternative equality
constraint function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative
equality constraint function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_ceq\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_curv:cobyqa-optimize-trustregion-model-ceq-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_curv::doc}}
\sphinxAtStartPar
method
\index{model\_ceq\_curv() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_ceq\_curv()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_curv:cobyqa.optimize.TrustRegion.model_ceq_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_ceq\_curv}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the curvature of an equality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the \sphinxstyleemphasis{i}\sphinxhyphen{}th equality constraint function of the model at
\sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_ceq\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_grad:cobyqa-optimize-trustregion-model-ceq-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_grad::doc}}
\sphinxAtStartPar
method
\index{model\_ceq\_grad() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_ceq\_grad()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_grad:cobyqa.optimize.TrustRegion.model_ceq_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_ceq\_grad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the gradient of an equality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the \sphinxstyleemphasis{i}\sphinxhyphen{}th equality constraint function of the model at
\sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_ceq\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_hess:cobyqa-optimize-trustregion-model-ceq-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_hess::doc}}
\sphinxAtStartPar
method
\index{model\_ceq\_hess() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_ceq\_hess()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_hess:cobyqa.optimize.TrustRegion.model_ceq_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_ceq\_hess}}}{\emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of an equality constraint function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th equality constraint function of the
model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_ceq\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_hessp:cobyqa-optimize-trustregion-model-ceq-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_hessp::doc}}
\sphinxAtStartPar
method
\index{model\_ceq\_hessp() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_ceq\_hessp()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_ceq_hessp:cobyqa.optimize.TrustRegion.model_ceq_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_ceq\_hessp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an equality constraint
function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th equality
constraint function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_cub}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub:cobyqa-optimize-trustregion-model-cub}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub::doc}}
\sphinxAtStartPar
method
\index{model\_cub() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_cub()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub:cobyqa.optimize.TrustRegion.model_cub}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_cub}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate an inequality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the \sphinxstyleemphasis{i}\sphinxhyphen{}th inequality constraint function of the model at
\sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_cub\_alt}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt:cobyqa-optimize-trustregion-model-cub-alt}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt::doc}}
\sphinxAtStartPar
method
\index{model\_cub\_alt() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_cub\_alt()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt:cobyqa.optimize.TrustRegion.model_cub_alt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_cub\_alt}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate an alternative inequality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative inequality constraint function of
the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_cub\_alt\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_curv:cobyqa-optimize-trustregion-model-cub-alt-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_curv::doc}}
\sphinxAtStartPar
method
\index{model\_cub\_alt\_curv() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_cub\_alt\_curv()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_curv:cobyqa.optimize.TrustRegion.model_cub_alt_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_cub\_alt\_curv}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the curvature of an alternative inequality constraint function
of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative inequality constraint function
of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_cub\_alt\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_grad:cobyqa-optimize-trustregion-model-cub-alt-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_grad::doc}}
\sphinxAtStartPar
method
\index{model\_cub\_alt\_grad() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_cub\_alt\_grad()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_grad:cobyqa.optimize.TrustRegion.model_cub_alt_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_cub\_alt\_grad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the gradient of an alternative inequality constraint function
of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative inequality constraint function of
the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_cub\_alt\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_hess:cobyqa-optimize-trustregion-model-cub-alt-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_hess::doc}}
\sphinxAtStartPar
method
\index{model\_cub\_alt\_hess() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_cub\_alt\_hess()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_hess:cobyqa.optimize.TrustRegion.model_cub_alt_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_cub\_alt\_hess}}}{\emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of an alternative inequality constraint
function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative inequality constraint
function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_cub\_alt\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_hessp:cobyqa-optimize-trustregion-model-cub-alt-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_hessp::doc}}
\sphinxAtStartPar
method
\index{model\_cub\_alt\_hessp() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_cub\_alt\_hessp()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_alt_hessp:cobyqa.optimize.TrustRegion.model_cub_alt_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_cub\_alt\_hessp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an alternative inequality
constraint function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative
inequality constraint function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_cub\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_curv:cobyqa-optimize-trustregion-model-cub-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_curv::doc}}
\sphinxAtStartPar
method
\index{model\_cub\_curv() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_cub\_curv()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_curv:cobyqa.optimize.TrustRegion.model_cub_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_cub\_curv}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the curvature of an inequality constraint function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the \sphinxstyleemphasis{i}\sphinxhyphen{}th inequality constraint function of the model
at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_cub\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_grad:cobyqa-optimize-trustregion-model-cub-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_grad::doc}}
\sphinxAtStartPar
method
\index{model\_cub\_grad() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_cub\_grad()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_grad:cobyqa.optimize.TrustRegion.model_cub_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_cub\_grad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the gradient of an inequality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the \sphinxstyleemphasis{i}\sphinxhyphen{}th inequality constraint function of the model
at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_cub\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_hess:cobyqa-optimize-trustregion-model-cub-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_hess::doc}}
\sphinxAtStartPar
method
\index{model\_cub\_hess() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_cub\_hess()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_hess:cobyqa.optimize.TrustRegion.model_cub_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_cub\_hess}}}{\emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of an inequality constraint function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th inequality constraint function of the
model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_cub\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_hessp:cobyqa-optimize-trustregion-model-cub-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_hessp::doc}}
\sphinxAtStartPar
method
\index{model\_cub\_hessp() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_cub\_hessp()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_cub_hessp:cobyqa.optimize.TrustRegion.model_cub_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_cub\_hessp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an inequality constraint
function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th inequality
constraint function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_lag}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag:cobyqa-optimize-trustregion-model-lag}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag::doc}}
\sphinxAtStartPar
method
\index{model\_lag() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_lag()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag:cobyqa.optimize.TrustRegion.model_lag}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_lag}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the Lagrangian function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the Lagrangian function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_lag\_alt}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt:cobyqa-optimize-trustregion-model-lag-alt}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt::doc}}
\sphinxAtStartPar
method
\index{model\_lag\_alt() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_lag\_alt()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt:cobyqa.optimize.TrustRegion.model_lag_alt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_lag\_alt}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the alternative Lagrangian function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the alternative Lagrangian function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_lag\_alt\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_curv:cobyqa-optimize-trustregion-model-lag-alt-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_curv::doc}}
\sphinxAtStartPar
method
\index{model\_lag\_alt\_curv() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_lag\_alt\_curv()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_curv:cobyqa.optimize.TrustRegion.model_lag_alt_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_lag\_alt\_curv}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the curvature of the alternative Lagrangian function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the alternative Lagrangian function of the model at
\sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_lag\_alt\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_grad:cobyqa-optimize-trustregion-model-lag-alt-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_grad::doc}}
\sphinxAtStartPar
method
\index{model\_lag\_alt\_grad() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_lag\_alt\_grad()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_grad:cobyqa.optimize.TrustRegion.model_lag_alt_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_lag\_alt\_grad}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the gradient of the alternative Lagrangian function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the alternative Lagrangian function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_lag\_alt\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_hess:cobyqa-optimize-trustregion-model-lag-alt-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_hess::doc}}
\sphinxAtStartPar
method
\index{model\_lag\_alt\_hess() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_lag\_alt\_hess()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_hess:cobyqa.optimize.TrustRegion.model_lag_alt_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_lag\_alt\_hess}}}{}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of the alternative Lagrangian function of
the model.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the alternative Lagrangian function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_lag\_alt\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_hessp:cobyqa-optimize-trustregion-model-lag-alt-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_hessp::doc}}
\sphinxAtStartPar
method
\index{model\_lag\_alt\_hessp() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_lag\_alt\_hessp()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_alt_hessp:cobyqa.optimize.TrustRegion.model_lag_alt_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_lag\_alt\_hessp}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the alternative Lagrangian
function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the alternative
Lagrangian function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_lag\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_curv:cobyqa-optimize-trustregion-model-lag-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_curv::doc}}
\sphinxAtStartPar
method
\index{model\_lag\_curv() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_lag\_curv()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_curv:cobyqa.optimize.TrustRegion.model_lag_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_lag\_curv}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the curvature of the Lagrangian function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the Lagrangian function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_lag\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_grad:cobyqa-optimize-trustregion-model-lag-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_grad::doc}}
\sphinxAtStartPar
method
\index{model\_lag\_grad() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_lag\_grad()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_grad:cobyqa.optimize.TrustRegion.model_lag_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_lag\_grad}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the gradient of Lagrangian function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the Lagrangian function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_lag\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_hess:cobyqa-optimize-trustregion-model-lag-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_hess::doc}}
\sphinxAtStartPar
method
\index{model\_lag\_hess() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_lag\_hess()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_hess:cobyqa.optimize.TrustRegion.model_lag_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_lag\_hess}}}{}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of the Lagrangian function of the model.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the Lagrangian function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_lag\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_hessp:cobyqa-optimize-trustregion-model-lag-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_hessp::doc}}
\sphinxAtStartPar
method
\index{model\_lag\_hessp() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_lag\_hessp()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_lag_hessp:cobyqa.optimize.TrustRegion.model_lag_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_lag\_hessp}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the Lagrangian function of
the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the Lagrangian
function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_obj}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj:cobyqa-optimize-trustregion-model-obj}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj::doc}}
\sphinxAtStartPar
method
\index{model\_obj() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_obj()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj:cobyqa.optimize.TrustRegion.model_obj}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_obj}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the objective function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_obj\_alt}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt:cobyqa-optimize-trustregion-model-obj-alt}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt::doc}}
\sphinxAtStartPar
method
\index{model\_obj\_alt() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_obj\_alt()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt:cobyqa.optimize.TrustRegion.model_obj_alt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_obj\_alt}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the alternative objective function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the alternative objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_obj\_alt\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_curv:cobyqa-optimize-trustregion-model-obj-alt-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_curv::doc}}
\sphinxAtStartPar
method
\index{model\_obj\_alt\_curv() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_obj\_alt\_curv()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_curv:cobyqa.optimize.TrustRegion.model_obj_alt_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_obj\_alt\_curv}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the curvature of the alternative objective function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the alternative objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_obj\_alt\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_grad:cobyqa-optimize-trustregion-model-obj-alt-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_grad::doc}}
\sphinxAtStartPar
method
\index{model\_obj\_alt\_grad() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_obj\_alt\_grad()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_grad:cobyqa.optimize.TrustRegion.model_obj_alt_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_obj\_alt\_grad}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the gradient of the alternative objective function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the alternative objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_obj\_alt\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_hess:cobyqa-optimize-trustregion-model-obj-alt-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_hess::doc}}
\sphinxAtStartPar
method
\index{model\_obj\_alt\_hess() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_obj\_alt\_hess()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_hess:cobyqa.optimize.TrustRegion.model_obj_alt_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_obj\_alt\_hess}}}{}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of the alternative objective function of the
model.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the alternative objective function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_obj\_alt\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_hessp:cobyqa-optimize-trustregion-model-obj-alt-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_hessp::doc}}
\sphinxAtStartPar
method
\index{model\_obj\_alt\_hessp() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_obj\_alt\_hessp()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_alt_hessp:cobyqa.optimize.TrustRegion.model_obj_alt_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_obj\_alt\_hessp}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the alternative objective
function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the alternative
objective function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_obj\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_curv:cobyqa-optimize-trustregion-model-obj-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_curv::doc}}
\sphinxAtStartPar
method
\index{model\_obj\_curv() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_obj\_curv()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_curv:cobyqa.optimize.TrustRegion.model_obj_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_obj\_curv}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the curvature of the objective function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_obj\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_grad:cobyqa-optimize-trustregion-model-obj-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_grad::doc}}
\sphinxAtStartPar
method
\index{model\_obj\_grad() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_obj\_grad()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_grad:cobyqa.optimize.TrustRegion.model_obj_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_obj\_grad}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the gradient of the objective function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_obj\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_hess:cobyqa-optimize-trustregion-model-obj-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_hess::doc}}
\sphinxAtStartPar
method
\index{model\_obj\_hess() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_obj\_hess()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_hess:cobyqa.optimize.TrustRegion.model_obj_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_obj\_hess}}}{}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of the objective function of the model.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the objective function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_obj\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_hessp:cobyqa-optimize-trustregion-model-obj-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_hessp::doc}}
\sphinxAtStartPar
method
\index{model\_obj\_hessp() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_obj\_hessp()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_obj_hessp:cobyqa.optimize.TrustRegion.model_obj_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_obj\_hessp}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the objective function of
the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the objective function
of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.model\_step}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_step:cobyqa-optimize-trustregion-model-step}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_step::doc}}
\sphinxAtStartPar
method
\index{model\_step() (cobyqa.optimize.TrustRegion method)@\spxentry{model\_step()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.model_step:cobyqa.optimize.TrustRegion.model_step}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{model\_step}}}{\emph{\DUrole{n}{delta}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Estimate a model\sphinxhyphen{}improvement step from \sphinxcode{\sphinxupquote{xopt}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{delta}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Trust\sphinxhyphen{}region radius.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Model\sphinxhyphen{}improvement step from \sphinxcode{\sphinxupquote{xopt}}.

\end{description}

\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{bdtol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the bound constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * n * max(1, max(abs(xl)), max(abs(xu)))}}, where the
values of \sphinxcode{\sphinxupquote{xl}} and \sphinxcode{\sphinxupquote{xu}} evolve to include the shift of the
origin).

\end{description}

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Two alternative steps are computed.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The first alternative step is selected on the lines that join
\sphinxcode{\sphinxupquote{xopt}} to the other interpolation points that maximize a lower
bound on the denominator of the updating formula.

\item {} 
\sphinxAtStartPar
The second alternative is a constrained Cauchy step.

\end{enumerate}

\sphinxAtStartPar
Among the two alternative steps, the method selects the one that leads
to the greatest denominator in Equation (2.12) of \sphinxcite{refs/generated/cobyqa.optimize.TrustRegion.model_step:r91f0d0960ad4-powe04}.
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.optimize.TrustRegion.model_step:r91f0d0960ad4-powe04}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.prepare\_model\_step}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.prepare_model_step:cobyqa-optimize-trustregion-prepare-model-step}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.prepare_model_step::doc}}
\sphinxAtStartPar
method
\index{prepare\_model\_step() (cobyqa.optimize.TrustRegion method)@\spxentry{prepare\_model\_step()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.prepare_model_step:cobyqa.optimize.TrustRegion.prepare_model_step}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{prepare\_model\_step}}}{\emph{\DUrole{n}{delta}}}{}
\sphinxAtStartPar
Set the next iteration to a model\sphinxhyphen{}step if necessary.

\sphinxAtStartPar
The method checks whether the furthest interpolation point from
\sphinxcode{\sphinxupquote{xopt}} is more than the provided trust\sphinxhyphen{}region radius to set a
model\sphinxhyphen{}step. If such a point does not exist, the next iteration is a
trust\sphinxhyphen{}region step.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{delta}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Trust\sphinxhyphen{}region radius.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.prepare\_trust\_region\_step}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.prepare_trust_region_step:cobyqa-optimize-trustregion-prepare-trust-region-step}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.prepare_trust_region_step::doc}}
\sphinxAtStartPar
method
\index{prepare\_trust\_region\_step() (cobyqa.optimize.TrustRegion method)@\spxentry{prepare\_trust\_region\_step()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.prepare_trust_region_step:cobyqa.optimize.TrustRegion.prepare_trust_region_step}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{prepare\_trust\_region\_step}}}{}{}
\sphinxAtStartPar
Set the next iteration to a trust\sphinxhyphen{}region step.

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.reduce\_penalty\_coefficients}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.reduce_penalty_coefficients:cobyqa-optimize-trustregion-reduce-penalty-coefficients}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.reduce_penalty_coefficients::doc}}
\sphinxAtStartPar
method
\index{reduce\_penalty\_coefficients() (cobyqa.optimize.TrustRegion method)@\spxentry{reduce\_penalty\_coefficients()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.reduce_penalty_coefficients:cobyqa.optimize.TrustRegion.reduce_penalty_coefficients}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{reduce\_penalty\_coefficients}}}{}{}
\sphinxAtStartPar
Reduce the penalty coefficients if possible, to prevent overflows.
\subsubsection*{Notes}

\sphinxAtStartPar
The thresholds at which the penalty coefficients are set are empirical
and based on Equation (13) of \sphinxcite{refs/generated/cobyqa.optimize.TrustRegion.reduce_penalty_coefficients:r8e0aa6026fda-powe94}.
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.optimize.TrustRegion.reduce_penalty_coefficients:r8e0aa6026fda-powe94}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.reset\_models}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.reset_models:cobyqa-optimize-trustregion-reset-models}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.reset_models::doc}}
\sphinxAtStartPar
method
\index{reset\_models() (cobyqa.optimize.TrustRegion method)@\spxentry{reset\_models()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.reset_models:cobyqa.optimize.TrustRegion.reset_models}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{reset\_models}}}{}{}
\sphinxAtStartPar
Reset the models.

\sphinxAtStartPar
The standard models of the objective function, the nonlinear inequality
constraint function, and the nonlinear equality constraint function are
set to the ones whose Hessian matrices are least in Frobenius norm.

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.set\_default\_options}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.set_default_options:cobyqa-optimize-trustregion-set-default-options}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.set_default_options::doc}}
\sphinxAtStartPar
method
\index{set\_default\_options() (cobyqa.optimize.TrustRegion method)@\spxentry{set\_default\_options()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.set_default_options:cobyqa.optimize.TrustRegion.set_default_options}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{set\_default\_options}}}{\emph{\DUrole{n}{n}}}{}
\sphinxAtStartPar
Set the default options for the solvers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{n}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Number of decision variables.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.shift\_origin}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.shift_origin:cobyqa-optimize-trustregion-shift-origin}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.shift_origin::doc}}
\sphinxAtStartPar
method
\index{shift\_origin() (cobyqa.optimize.TrustRegion method)@\spxentry{shift\_origin()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.shift_origin:cobyqa.optimize.TrustRegion.shift_origin}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{shift\_origin}}}{\emph{\DUrole{n}{delta}}}{}
\sphinxAtStartPar
Shift the origin of the calculations if necessary.

\sphinxAtStartPar
Although the shift of the origin in the calculations does not change
anything from a theoretical point of view, it is designed to tackle
numerical difficulties caused by ill\sphinxhyphen{}conditioned problems. If the method
is triggered, the origin is shifted to the best point so far.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{delta}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Trust\sphinxhyphen{}region radius.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.trust\_region\_step}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.trust_region_step:cobyqa-optimize-trustregion-trust-region-step}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.trust_region_step::doc}}
\sphinxAtStartPar
method
\index{trust\_region\_step() (cobyqa.optimize.TrustRegion method)@\spxentry{trust\_region\_step()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.trust_region_step:cobyqa.optimize.TrustRegion.trust_region_step}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{trust\_region\_step}}}{\emph{\DUrole{n}{delta}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Evaluate a Byrd\sphinxhyphen{}Omojokun\sphinxhyphen{}like trust\sphinxhyphen{}region step from \sphinxcode{\sphinxupquote{xopt}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{delta}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Trust\sphinxhyphen{}region radius.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Trust\sphinxhyphen{}region step from \sphinxcode{\sphinxupquote{xopt}}.

\end{description}

\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{bdtol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the bound constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * n * max(1, max(abs(xl)), max(abs(xu)))}}, where the
values of \sphinxcode{\sphinxupquote{xl}} and \sphinxcode{\sphinxupquote{xu}} evolve to include the shift of the
origin).

\item[{\sphinxstylestrong{lctol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the linear constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * max(mlub, n) * max(1, max(abs(bub)))}}, where the
values of \sphinxcode{\sphinxupquote{bub}} evolve to include the shift of the origin).

\end{description}

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
The trust\sphinxhyphen{}region constraint of the tangential subproblem is not centered
if the normal step is nonzero. To cope with this difficulty, we use the
result presented in Equation (15.4.3) of \sphinxcite{refs/generated/cobyqa.optimize.TrustRegion.trust_region_step:ra296b548e366-cogt09}.
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.optimize.TrustRegion.trust_region_step:ra296b548e366-cogt09}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.update}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update:cobyqa-optimize-trustregion-update}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update::doc}}
\sphinxAtStartPar
method
\index{update() (cobyqa.optimize.TrustRegion method)@\spxentry{update()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update:cobyqa.optimize.TrustRegion.update}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{step}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Include a new point in the interpolation set.

\sphinxAtStartPar
When the new point is included in the interpolation set, the models of
the nonlinear optimization problems are updated.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{step}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Step from \sphinxcode{\sphinxupquote{xopt}} of the new point to include in the interpolation
set.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{mopt}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Merit value of the new interpolation point.

\item[{\sphinxstylestrong{ratio}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Trust\sphinxhyphen{}region ratio associated with the new interpolation point.

\end{description}

\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{bdtol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the bound constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * n * max(1, max(abs(xl)), max(abs(xu)))}}.

\item[{\sphinxstylestrong{lstol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance on the approximate KKT conditions for the calculations of
the least\sphinxhyphen{}squares Lagrange multipliers (the default is
\sphinxcode{\sphinxupquote{10 * eps * max(n, m) * max(1, max(abs(g)))}}, where \sphinxcode{\sphinxupquote{g}} is the
gradient of the current model of the objective function).

\end{description}

\item[{Raises}] \leavevmode\begin{description}
\item[{RestartRequiredException}] \leavevmode
\sphinxAtStartPar
The iteration must be restarted because the index of the optimal
point among the interpolation set has changed.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.update\_multipliers}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update_multipliers:cobyqa-optimize-trustregion-update-multipliers}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update_multipliers::doc}}
\sphinxAtStartPar
method
\index{update\_multipliers() (cobyqa.optimize.TrustRegion method)@\spxentry{update\_multipliers()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update_multipliers:cobyqa.optimize.TrustRegion.update_multipliers}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{update\_multipliers}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Set the least\sphinxhyphen{}squares Lagrange multipliers.
\begin{quote}\begin{description}
\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{lstol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance on the approximate KKT conditions for the calculations of
the least\sphinxhyphen{}squares Lagrange multipliers (the default is
\sphinxcode{\sphinxupquote{10 * eps * max(n, m) * max(1, max(abs(g)))}}, where \sphinxcode{\sphinxupquote{g}} is the
gradient of the current model of the objective function).

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.TrustRegion.update\_penalty\_parameters}
\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update_penalty_parameters:cobyqa-optimize-trustregion-update-penalty-parameters}}\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update_penalty_parameters::doc}}
\sphinxAtStartPar
method
\index{update\_penalty\_parameters() (cobyqa.optimize.TrustRegion method)@\spxentry{update\_penalty\_parameters()}\spxextra{cobyqa.optimize.TrustRegion method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.TrustRegion.update_penalty_parameters:cobyqa.optimize.TrustRegion.update_penalty_parameters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.TrustRegion.}}\sphinxbfcode{\sphinxupquote{update\_penalty\_parameters}}}{\emph{\DUrole{n}{step}}, \emph{\DUrole{n}{fx}}, \emph{\DUrole{n}{cubx}}, \emph{\DUrole{n}{ceqx}}}{}
\sphinxAtStartPar
Increase the penalty coefficients.

\sphinxAtStartPar
The penalty coefficients are increased to make the trust\sphinxhyphen{}region ratio
meaningful. The increasing process of the penalty coefficients may be
prematurely stop if the index of the best point so far changes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{step}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Trial step from \sphinxcode{\sphinxupquote{xopt}}.

\item[{\sphinxstylestrong{fx}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Value of the objective function at the trial point.

\item[{\sphinxstylestrong{cubx}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Value of the nonlinear inequality constraint function at the trial
point.

\item[{\sphinxstylestrong{ceqx}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Value of the nonlinear equality constraint function at the trial
point.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{mx}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Value of the merit function at the trial point, evaluated on the
nonlinear optimization problem.

\item[{\sphinxstylestrong{mmx}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Value of the merit function at the trial point, evaluated on the
different models.

\item[{\sphinxstylestrong{mopt}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Value of the merit function at \sphinxcode{\sphinxupquote{xopt}}, evaluated on the nonlinear
optimization problem.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{cobyqa.optimize.Models}
\label{\detokenize{refs/generated/cobyqa.optimize.Models:cobyqa-optimize-models}}\label{\detokenize{refs/generated/cobyqa.optimize.Models::doc}}\index{Models (class in cobyqa.optimize)@\spxentry{Models}\spxextra{class in cobyqa.optimize}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models:cobyqa.optimize.Models}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{cobyqa.optimize.}}\sphinxbfcode{\sphinxupquote{Models}}}{\emph{\DUrole{n}{fun}}, \emph{\DUrole{n}{x0}}, \emph{\DUrole{n}{xl}}, \emph{\DUrole{n}{xu}}, \emph{\DUrole{n}{Aub}}, \emph{\DUrole{n}{bub}}, \emph{\DUrole{n}{Aeq}}, \emph{\DUrole{n}{beq}}, \emph{\DUrole{n}{cub}}, \emph{\DUrole{n}{ceq}}, \emph{\DUrole{n}{options}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Model a nonlinear optimization problem.

\sphinxAtStartPar
The nonlinear optimization problem is modeled using quadratic functions
obtained by underdetermined interpolation. The interpolation points may be
infeasible with respect to the linear and nonlinear constraints, but they
always satisfy the bound constraints.
\subsubsection*{Notes}

\sphinxAtStartPar
Given the interpolation set, the freedom bequeathed by the interpolation
conditions is taken up by minimizing the updates of the Hessian matrices of
the objective and nonlinear constraint functions in Frobenius norm
\sphinxcite{refs/generated/cobyqa.optimize.Models:ra9ae06802801-powe04}.
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.optimize.Models:ra9ae06802801-powe04}
\begin{quote}\begin{description}
\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxcode{\sphinxupquote{aeq}}}] \leavevmode
\sphinxAtStartPar
Jacobian matrix of the normalized linear equality constraints.

\item[{\sphinxcode{\sphinxupquote{aub}}}] \leavevmode
\sphinxAtStartPar
Jacobian matrix of the normalized linear inequality constraints.

\item[{\sphinxcode{\sphinxupquote{beq}}}] \leavevmode
\sphinxAtStartPar
Right\sphinxhyphen{}hand side vector of the normalized linear equality constraints.

\item[{\sphinxcode{\sphinxupquote{bmat}}}] \leavevmode
\sphinxAtStartPar
Last \sphinxcode{\sphinxupquote{n}} columns of the inverse KKT matrix of interpolation.

\item[{\sphinxcode{\sphinxupquote{bub}}}] \leavevmode
\sphinxAtStartPar
Right\sphinxhyphen{}hand side vector of the normalized linear inequality constraints.

\item[{\sphinxcode{\sphinxupquote{copteq}}}] \leavevmode
\sphinxAtStartPar
Evaluation of the nonlinear equality constraint function of the nonlinear optimization problem at \sphinxcode{\sphinxupquote{xopt}}.

\item[{\sphinxcode{\sphinxupquote{coptub}}}] \leavevmode
\sphinxAtStartPar
Evaluation of the nonlinear inequality constraint function of the nonlinear optimization problem at \sphinxcode{\sphinxupquote{xopt}}.

\item[{\sphinxcode{\sphinxupquote{cvaleq}}}] \leavevmode
\sphinxAtStartPar
Evaluations of the nonlinear equality constraint function of the nonlinear optimization problem at the interpolation points.

\item[{\sphinxcode{\sphinxupquote{cvalub}}}] \leavevmode
\sphinxAtStartPar
Evaluations of the nonlinear inequality constraint function of the nonlinear optimization problem at the interpolation points.

\item[{\sphinxcode{\sphinxupquote{fopt}}}] \leavevmode
\sphinxAtStartPar
Evaluation of the objective function of the nonlinear optimization problem at \sphinxcode{\sphinxupquote{xopt}}.

\item[{\sphinxcode{\sphinxupquote{fval}}}] \leavevmode
\sphinxAtStartPar
Evaluations of the objective function of the nonlinear optimization problem at the interpolation points.

\item[{\sphinxcode{\sphinxupquote{idz}}}] \leavevmode
\sphinxAtStartPar
Number of nonpositive eigenvalues of the leading \sphinxcode{\sphinxupquote{npt}} submatrix of the inverse KKT matrix of interpolation.

\item[{\sphinxcode{\sphinxupquote{kopt}}}] \leavevmode
\sphinxAtStartPar
Index of the interpolation point around which the Taylor expansions of the quadratic models are defined.

\item[{\sphinxcode{\sphinxupquote{mleq}}}] \leavevmode
\sphinxAtStartPar
Number of the linear equality constraints.

\item[{\sphinxcode{\sphinxupquote{mlub}}}] \leavevmode
\sphinxAtStartPar
Number of the linear inequality constraints.

\item[{\sphinxcode{\sphinxupquote{mnleq}}}] \leavevmode
\sphinxAtStartPar
Number of the nonlinear equality constraints.

\item[{\sphinxcode{\sphinxupquote{mnlub}}}] \leavevmode
\sphinxAtStartPar
Number of the nonlinear inequality constraints.

\item[{\sphinxcode{\sphinxupquote{ropt}}}] \leavevmode
\sphinxAtStartPar
Residual associated with the constraints of the nonlinear optimization problem at \sphinxcode{\sphinxupquote{xopt}}.

\item[{\sphinxcode{\sphinxupquote{rval}}}] \leavevmode
\sphinxAtStartPar
Residuals associated with the constraints of the nonlinear optimization problem at the interpolation points.

\item[{\sphinxcode{\sphinxupquote{target\_reached}}}] \leavevmode
\sphinxAtStartPar
Indicate whether the computations have been stopped because the target value has been reached.

\item[{\sphinxcode{\sphinxupquote{type}}}] \leavevmode
\sphinxAtStartPar
Type of the nonlinear optimization problem.

\item[{\sphinxcode{\sphinxupquote{xl}}}] \leavevmode
\sphinxAtStartPar
Lower\sphinxhyphen{}bound constraints on the decision variables.

\item[{\sphinxcode{\sphinxupquote{xopt}}}] \leavevmode
\sphinxAtStartPar
Interpolation point around which the Taylor expansion of the quadratic models are defined.

\item[{\sphinxcode{\sphinxupquote{xpt}}}] \leavevmode
\sphinxAtStartPar
Displacements of the interpolation points from the origin.

\item[{\sphinxcode{\sphinxupquote{xu}}}] \leavevmode
\sphinxAtStartPar
Upper\sphinxhyphen{}bound constraints on the decision variables.

\item[{\sphinxcode{\sphinxupquote{zmat}}}] \leavevmode
\sphinxAtStartPar
Rank factorization matrix of the leading \sphinxcode{\sphinxupquote{npt}} submatrix of the inverse KKT matrix of interpolation.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.ceq:cobyqa.optimize.Models.ceq}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ceq}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate an equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt:cobyqa.optimize.Models.ceq_alt}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ceq\_alt}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate an alternative equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_curv:cobyqa.optimize.Models.ceq_alt_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ceq\_alt\_curv}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the curvature of an alternative equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_grad:cobyqa.optimize.Models.ceq_alt_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ceq\_alt\_grad}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the gradient of an alternative equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_hess:cobyqa.optimize.Models.ceq_alt_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ceq\_alt\_hess}}}}}(i)
&
\sphinxAtStartPar
Evaluate the Hessian matrix of an alternative equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_hessp:cobyqa.optimize.Models.ceq_alt_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ceq\_alt\_hessp}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an alternative equality constraint function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.ceq_curv:cobyqa.optimize.Models.ceq_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ceq\_curv}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the curvature of an equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.ceq_grad:cobyqa.optimize.Models.ceq_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ceq\_grad}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the gradient of an equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.ceq_hess:cobyqa.optimize.Models.ceq_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ceq\_hess}}}}}(i)
&
\sphinxAtStartPar
Evaluate the Hessian matrix of an equality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.ceq_hessp:cobyqa.optimize.Models.ceq_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ceq\_hessp}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an equality constraint function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.check_models:cobyqa.optimize.Models.check_models}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{check\_models}}}}}({[}stack\_level{]})
&
\sphinxAtStartPar
Check the interpolation conditions.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.cub:cobyqa.optimize.Models.cub}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cub}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate an inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt:cobyqa.optimize.Models.cub_alt}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cub\_alt}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate an alternative inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_curv:cobyqa.optimize.Models.cub_alt_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cub\_alt\_curv}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the curvature of an alternative inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_grad:cobyqa.optimize.Models.cub_alt_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cub\_alt\_grad}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the gradient of an alternative inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_hess:cobyqa.optimize.Models.cub_alt_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cub\_alt\_hess}}}}}(i)
&
\sphinxAtStartPar
Evaluate the Hessian matrix of an alternative inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_hessp:cobyqa.optimize.Models.cub_alt_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cub\_alt\_hessp}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an alternative inequality constraint function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.cub_curv:cobyqa.optimize.Models.cub_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cub\_curv}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the curvature of an inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.cub_grad:cobyqa.optimize.Models.cub_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cub\_grad}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the gradient of an inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.cub_hess:cobyqa.optimize.Models.cub_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cub\_hess}}}}}(i)
&
\sphinxAtStartPar
Evaluate the Hessian matrix of an inequality constraint function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.cub_hessp:cobyqa.optimize.Models.cub_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cub\_hessp}}}}}(x, i)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an inequality constraint function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.improve_geometry:cobyqa.optimize.Models.improve_geometry}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{improve\_geometry}}}}}(klag, delta, **kwargs)
&
\sphinxAtStartPar
Estimate a step from \sphinxcode{\sphinxupquote{xopt}} that aims at improving the geometry of the interpolation set.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.lag:cobyqa.optimize.Models.lag}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lag}}}}}(x, lmlub, lmleq, lmnlub, lmnleq)
&
\sphinxAtStartPar
Evaluate the Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt:cobyqa.optimize.Models.lag_alt}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lag\_alt}}}}}(x, lmlub, lmleq, lmnlub, lmnleq)
&
\sphinxAtStartPar
Evaluate the alternative Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_curv:cobyqa.optimize.Models.lag_alt_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lag\_alt\_curv}}}}}(x, lmnlub, lmnleq)
&
\sphinxAtStartPar
Evaluate the curvature of the alternative Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_grad:cobyqa.optimize.Models.lag_alt_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lag\_alt\_grad}}}}}(x, lmlub, lmleq, lmnlub, lmnleq)
&
\sphinxAtStartPar
Evaluate the gradient of the alternative Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_hess:cobyqa.optimize.Models.lag_alt_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lag\_alt\_hess}}}}}(lmnlub, lmnleq)
&
\sphinxAtStartPar
Evaluate the Hessian matrix of the alternative Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_hessp:cobyqa.optimize.Models.lag_alt_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lag\_alt\_hessp}}}}}(x, lmnlub, lmnleq)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the alternative Lagrangian function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.lag_curv:cobyqa.optimize.Models.lag_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lag\_curv}}}}}(x, lmnlub, lmnleq)
&
\sphinxAtStartPar
Evaluate the curvature of the Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.lag_grad:cobyqa.optimize.Models.lag_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lag\_grad}}}}}(x, lmlub, lmleq, lmnlub, lmnleq)
&
\sphinxAtStartPar
Evaluate the gradient of Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.lag_hess:cobyqa.optimize.Models.lag_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lag\_hess}}}}}(lmnlub, lmnleq)
&
\sphinxAtStartPar
Evaluate the Hessian matrix of the Lagrangian function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.lag_hessp:cobyqa.optimize.Models.lag_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lag\_hessp}}}}}(x, lmnlub, lmnleq)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the Lagrangian function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.new_model:cobyqa.optimize.Models.new_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{new\_model}}}}}(val)
&
\sphinxAtStartPar
Generate a model obtained by underdetermined interpolation.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.normalize_constraints:cobyqa.optimize.Models.normalize_constraints}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{normalize\_constraints}}}}}()
&
\sphinxAtStartPar
Normalize the linear constraints.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.obj:cobyqa.optimize.Models.obj}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{obj}}}}}(x)
&
\sphinxAtStartPar
Evaluate the objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt:cobyqa.optimize.Models.obj_alt}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{obj\_alt}}}}}(x)
&
\sphinxAtStartPar
Evaluate the alternative objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_curv:cobyqa.optimize.Models.obj_alt_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{obj\_alt\_curv}}}}}(x)
&
\sphinxAtStartPar
Evaluate the curvature of the alternative objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_grad:cobyqa.optimize.Models.obj_alt_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{obj\_alt\_grad}}}}}(x)
&
\sphinxAtStartPar
Evaluate the gradient of the alternative objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_hess:cobyqa.optimize.Models.obj_alt_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{obj\_alt\_hess}}}}}()
&
\sphinxAtStartPar
Evaluate the Hessian matrix of the alternative objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_hessp:cobyqa.optimize.Models.obj_alt_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{obj\_alt\_hessp}}}}}(x)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the alternative objective function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.obj_curv:cobyqa.optimize.Models.obj_curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{obj\_curv}}}}}(x)
&
\sphinxAtStartPar
Evaluate the curvature of the objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.obj_grad:cobyqa.optimize.Models.obj_grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{obj\_grad}}}}}(x)
&
\sphinxAtStartPar
Evaluate the gradient of the objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.obj_hess:cobyqa.optimize.Models.obj_hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{obj\_hess}}}}}()
&
\sphinxAtStartPar
Evaluate the Hessian matrix of the objective function of the model.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.obj_hessp:cobyqa.optimize.Models.obj_hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{obj\_hessp}}}}}(x)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the objective function of the model with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.reset_models:cobyqa.optimize.Models.reset_models}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{reset\_models}}}}}()
&
\sphinxAtStartPar
Reset the models.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.resid:cobyqa.optimize.Models.resid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{resid}}}}}(x{[}, cubx, ceqx{]})
&
\sphinxAtStartPar
Evaluate the residual associated with the constraints of the nonlinear optimization problem.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.shift_constraints:cobyqa.optimize.Models.shift_constraints}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{shift\_constraints}}}}}(x)
&
\sphinxAtStartPar
Shift the bound and linear constraints.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.shift_origin:cobyqa.optimize.Models.shift_origin}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{shift\_origin}}}}}()
&
\sphinxAtStartPar
Update the models when the origin of the calculations is modified.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Models.update:cobyqa.optimize.Models.update}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update}}}}}(step, fx, cubx, ceqx{[}, knew{]})
&
\sphinxAtStartPar
Update the models of the nonlinear optimization problem when a point of the interpolation set is modified.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsection{cobyqa.optimize.Models.ceq}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq:cobyqa-optimize-models-ceq}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq::doc}}
\sphinxAtStartPar
method
\index{ceq() (cobyqa.optimize.Models method)@\spxentry{ceq()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq:cobyqa.optimize.Models.ceq}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{ceq}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate an equality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the \sphinxstyleemphasis{i}\sphinxhyphen{}th equality constraint function of the model at
\sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.ceq\_alt}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt:cobyqa-optimize-models-ceq-alt}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt::doc}}
\sphinxAtStartPar
method
\index{ceq\_alt() (cobyqa.optimize.Models method)@\spxentry{ceq\_alt()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt:cobyqa.optimize.Models.ceq_alt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{ceq\_alt}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate an alternative equality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative equality constraint function of the
model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.ceq\_alt\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_curv:cobyqa-optimize-models-ceq-alt-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_curv::doc}}
\sphinxAtStartPar
method
\index{ceq\_alt\_curv() (cobyqa.optimize.Models method)@\spxentry{ceq\_alt\_curv()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_curv:cobyqa.optimize.Models.ceq_alt_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{ceq\_alt\_curv}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the curvature of an alternative equality constraint function of
the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative equality constraint function of
the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.ceq\_alt\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_grad:cobyqa-optimize-models-ceq-alt-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_grad::doc}}
\sphinxAtStartPar
method
\index{ceq\_alt\_grad() (cobyqa.optimize.Models method)@\spxentry{ceq\_alt\_grad()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_grad:cobyqa.optimize.Models.ceq_alt_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{ceq\_alt\_grad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the gradient of an alternative equality constraint function of
the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative equality constraint function of
the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.ceq\_alt\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_hess:cobyqa-optimize-models-ceq-alt-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_hess::doc}}
\sphinxAtStartPar
method
\index{ceq\_alt\_hess() (cobyqa.optimize.Models method)@\spxentry{ceq\_alt\_hess()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_hess:cobyqa.optimize.Models.ceq_alt_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{ceq\_alt\_hess}}}{\emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of an alternative equality constraint
function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative equality constraint
function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.ceq\_alt\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_hessp:cobyqa-optimize-models-ceq-alt-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_hessp::doc}}
\sphinxAtStartPar
method
\index{ceq\_alt\_hessp() (cobyqa.optimize.Models method)@\spxentry{ceq\_alt\_hessp()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_alt_hessp:cobyqa.optimize.Models.ceq_alt_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{ceq\_alt\_hessp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an alternative equality
constraint function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative
equality constraint function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.ceq\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_curv:cobyqa-optimize-models-ceq-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_curv::doc}}
\sphinxAtStartPar
method
\index{ceq\_curv() (cobyqa.optimize.Models method)@\spxentry{ceq\_curv()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_curv:cobyqa.optimize.Models.ceq_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{ceq\_curv}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the curvature of an equality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the \sphinxstyleemphasis{i}\sphinxhyphen{}th equality constraint function of the model at
\sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.ceq\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_grad:cobyqa-optimize-models-ceq-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_grad::doc}}
\sphinxAtStartPar
method
\index{ceq\_grad() (cobyqa.optimize.Models method)@\spxentry{ceq\_grad()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_grad:cobyqa.optimize.Models.ceq_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{ceq\_grad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the gradient of an equality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the \sphinxstyleemphasis{i}\sphinxhyphen{}th equality constraint function of the model at
\sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.ceq\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_hess:cobyqa-optimize-models-ceq-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_hess::doc}}
\sphinxAtStartPar
method
\index{ceq\_hess() (cobyqa.optimize.Models method)@\spxentry{ceq\_hess()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_hess:cobyqa.optimize.Models.ceq_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{ceq\_hess}}}{\emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of an equality constraint function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th equality constraint function of the
model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.ceq\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_hessp:cobyqa-optimize-models-ceq-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_hessp::doc}}
\sphinxAtStartPar
method
\index{ceq\_hessp() (cobyqa.optimize.Models method)@\spxentry{ceq\_hessp()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.ceq_hessp:cobyqa.optimize.Models.ceq_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{ceq\_hessp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an equality constraint
function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the equality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th equality
constraint function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.check\_models}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.check_models:cobyqa-optimize-models-check-models}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.check_models::doc}}
\sphinxAtStartPar
method
\index{check\_models() (cobyqa.optimize.Models method)@\spxentry{check\_models()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.check_models:cobyqa.optimize.Models.check_models}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{check\_models}}}{\emph{\DUrole{n}{stack\_level}\DUrole{o}{=}\DUrole{default_value}{2}}}{}
\sphinxAtStartPar
Check the interpolation conditions.

\sphinxAtStartPar
The method checks whether the evaluations of the quadratic models at the
interpolation points match their expected values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{stack\_level}}] \leavevmode{[}int, optional{]}
\sphinxAtStartPar
Stack level of the warning (the default is 2).

\end{description}

\item[{Warns}] \leavevmode\begin{description}
\item[{RuntimeWarning}] \leavevmode
\sphinxAtStartPar
The evaluations of a quadratic function do not satisfy the
interpolation conditions up to a certain tolerance.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.cub}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub:cobyqa-optimize-models-cub}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub::doc}}
\sphinxAtStartPar
method
\index{cub() (cobyqa.optimize.Models method)@\spxentry{cub()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub:cobyqa.optimize.Models.cub}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{cub}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate an inequality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the \sphinxstyleemphasis{i}\sphinxhyphen{}th inequality constraint function of the model at
\sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.cub\_alt}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt:cobyqa-optimize-models-cub-alt}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt::doc}}
\sphinxAtStartPar
method
\index{cub\_alt() (cobyqa.optimize.Models method)@\spxentry{cub\_alt()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt:cobyqa.optimize.Models.cub_alt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{cub\_alt}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate an alternative inequality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative inequality constraint function of
the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.cub\_alt\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_curv:cobyqa-optimize-models-cub-alt-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_curv::doc}}
\sphinxAtStartPar
method
\index{cub\_alt\_curv() (cobyqa.optimize.Models method)@\spxentry{cub\_alt\_curv()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_curv:cobyqa.optimize.Models.cub_alt_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{cub\_alt\_curv}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the curvature of an alternative inequality constraint function
of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative inequality constraint function
of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.cub\_alt\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_grad:cobyqa-optimize-models-cub-alt-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_grad::doc}}
\sphinxAtStartPar
method
\index{cub\_alt\_grad() (cobyqa.optimize.Models method)@\spxentry{cub\_alt\_grad()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_grad:cobyqa.optimize.Models.cub_alt_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{cub\_alt\_grad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the gradient of an alternative inequality constraint function
of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative inequality constraint function of
the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.cub\_alt\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_hess:cobyqa-optimize-models-cub-alt-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_hess::doc}}
\sphinxAtStartPar
method
\index{cub\_alt\_hess() (cobyqa.optimize.Models method)@\spxentry{cub\_alt\_hess()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_hess:cobyqa.optimize.Models.cub_alt_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{cub\_alt\_hess}}}{\emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of an alternative inequality constraint
function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative inequality constraint
function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.cub\_alt\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_hessp:cobyqa-optimize-models-cub-alt-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_hessp::doc}}
\sphinxAtStartPar
method
\index{cub\_alt\_hessp() (cobyqa.optimize.Models method)@\spxentry{cub\_alt\_hessp()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_alt_hessp:cobyqa.optimize.Models.cub_alt_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{cub\_alt\_hessp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an alternative inequality
constraint function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th alternative
inequality constraint function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.cub\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_curv:cobyqa-optimize-models-cub-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_curv::doc}}
\sphinxAtStartPar
method
\index{cub\_curv() (cobyqa.optimize.Models method)@\spxentry{cub\_curv()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_curv:cobyqa.optimize.Models.cub_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{cub\_curv}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the curvature of an inequality constraint function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the \sphinxstyleemphasis{i}\sphinxhyphen{}th inequality constraint function of the model
at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.cub\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_grad:cobyqa-optimize-models-cub-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_grad::doc}}
\sphinxAtStartPar
method
\index{cub\_grad() (cobyqa.optimize.Models method)@\spxentry{cub\_grad()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_grad:cobyqa.optimize.Models.cub_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{cub\_grad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the gradient of an inequality constraint function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the \sphinxstyleemphasis{i}\sphinxhyphen{}th inequality constraint function of the model
at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.cub\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_hess:cobyqa-optimize-models-cub-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_hess::doc}}
\sphinxAtStartPar
method
\index{cub\_hess() (cobyqa.optimize.Models method)@\spxentry{cub\_hess()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_hess:cobyqa.optimize.Models.cub_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{cub\_hess}}}{\emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of an inequality constraint function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th inequality constraint function of the
model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.cub\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_hessp:cobyqa-optimize-models-cub-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_hessp::doc}}
\sphinxAtStartPar
method
\index{cub\_hessp() (cobyqa.optimize.Models method)@\spxentry{cub\_hessp()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.cub_hessp:cobyqa.optimize.Models.cub_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{cub\_hessp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of an inequality constraint
function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the inequality constraint to be considered.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the \sphinxstyleemphasis{i}\sphinxhyphen{}th inequality
constraint function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.improve\_geometry}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.improve_geometry:cobyqa-optimize-models-improve-geometry}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.improve_geometry::doc}}
\sphinxAtStartPar
method
\index{improve\_geometry() (cobyqa.optimize.Models method)@\spxentry{improve\_geometry()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.improve_geometry:cobyqa.optimize.Models.improve_geometry}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{improve\_geometry}}}{\emph{\DUrole{n}{klag}}, \emph{\DUrole{n}{delta}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Estimate a step from \sphinxcode{\sphinxupquote{xopt}} that aims at improving the geometry of the
interpolation set.

\sphinxAtStartPar
Two alternative steps are computed.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The first alternative step is selected on the lines that join
\sphinxcode{\sphinxupquote{xopt}} to the other interpolation points that maximize a lower
bound on the denominator of the updating formula.

\item {} 
\sphinxAtStartPar
The second alternative is a constrained Cauchy step.

\end{enumerate}

\sphinxAtStartPar
Among the two alternative steps, the method selects the one that leads
to the greatest denominator of the updating formula.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{klag}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the interpolation point that is to be replaced.

\item[{\sphinxstylestrong{delta}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Upper bound on the length of the step.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Step from \sphinxcode{\sphinxupquote{xopt}} that aims at improving the geometry of the
interpolation set.

\end{description}

\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{bdtol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the bound constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * n * max(1, max(abs(xl)), max(abs(xu)))}}, where the
values of \sphinxcode{\sphinxupquote{xl}} and \sphinxcode{\sphinxupquote{xu}} evolve to include the shift of the
origin).

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.lag}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag:cobyqa-optimize-models-lag}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag::doc}}
\sphinxAtStartPar
method
\index{lag() (cobyqa.optimize.Models method)@\spxentry{lag()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag:cobyqa.optimize.Models.lag}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{lag}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{lmlub}}, \emph{\DUrole{n}{lmleq}}, \emph{\DUrole{n}{lmnlub}}, \emph{\DUrole{n}{lmnleq}}}{}
\sphinxAtStartPar
Evaluate the Lagrangian function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\item[{\sphinxstylestrong{lmlub}}] \leavevmode{[}numpy.ndarray, shape (mlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the linear inequality
constraints.

\item[{\sphinxstylestrong{lmleq}}] \leavevmode{[}numpy.ndarray, shape (mleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the linear equality
constraints.

\item[{\sphinxstylestrong{lmnlub}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear inequality constraints.

\item[{\sphinxstylestrong{lmnleq}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear equality constraints.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the Lagrangian function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.lag\_alt}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt:cobyqa-optimize-models-lag-alt}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt::doc}}
\sphinxAtStartPar
method
\index{lag\_alt() (cobyqa.optimize.Models method)@\spxentry{lag\_alt()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt:cobyqa.optimize.Models.lag_alt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{lag\_alt}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{lmlub}}, \emph{\DUrole{n}{lmleq}}, \emph{\DUrole{n}{lmnlub}}, \emph{\DUrole{n}{lmnleq}}}{}
\sphinxAtStartPar
Evaluate the alternative Lagrangian function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\item[{\sphinxstylestrong{lmlub}}] \leavevmode{[}numpy.ndarray, shape (mlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the linear inequality
constraints.

\item[{\sphinxstylestrong{lmleq}}] \leavevmode{[}numpy.ndarray, shape (mleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the linear equality
constraints.

\item[{\sphinxstylestrong{lmnlub}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear inequality constraints.

\item[{\sphinxstylestrong{lmnleq}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear equality constraints.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the alternative Lagrangian function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.lag\_alt\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_curv:cobyqa-optimize-models-lag-alt-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_curv::doc}}
\sphinxAtStartPar
method
\index{lag\_alt\_curv() (cobyqa.optimize.Models method)@\spxentry{lag\_alt\_curv()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_curv:cobyqa.optimize.Models.lag_alt_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{lag\_alt\_curv}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{lmnlub}}, \emph{\DUrole{n}{lmnleq}}}{}
\sphinxAtStartPar
Evaluate the curvature of the alternative Lagrangian function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{lmnlub}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear inequality constraints.

\item[{\sphinxstylestrong{lmnleq}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear equality constraints.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the alternative Lagrangian function of the model at
\sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.lag\_alt\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_grad:cobyqa-optimize-models-lag-alt-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_grad::doc}}
\sphinxAtStartPar
method
\index{lag\_alt\_grad() (cobyqa.optimize.Models method)@\spxentry{lag\_alt\_grad()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_grad:cobyqa.optimize.Models.lag_alt_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{lag\_alt\_grad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{lmlub}}, \emph{\DUrole{n}{lmleq}}, \emph{\DUrole{n}{lmnlub}}, \emph{\DUrole{n}{lmnleq}}}{}
\sphinxAtStartPar
Evaluate the gradient of the alternative Lagrangian function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{lmlub}}] \leavevmode{[}numpy.ndarray, shape (mlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the linear inequality
constraints.

\item[{\sphinxstylestrong{lmleq}}] \leavevmode{[}numpy.ndarray, shape (mleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the linear equality
constraints.

\item[{\sphinxstylestrong{lmnlub}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear inequality constraints.

\item[{\sphinxstylestrong{lmnleq}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear equality constraints.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the alternative Lagrangian function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.lag\_alt\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_hess:cobyqa-optimize-models-lag-alt-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_hess::doc}}
\sphinxAtStartPar
method
\index{lag\_alt\_hess() (cobyqa.optimize.Models method)@\spxentry{lag\_alt\_hess()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_hess:cobyqa.optimize.Models.lag_alt_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{lag\_alt\_hess}}}{\emph{\DUrole{n}{lmnlub}}, \emph{\DUrole{n}{lmnleq}}}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of the alternative Lagrangian function of
the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{lmnlub}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear inequality constraints.

\item[{\sphinxstylestrong{lmnleq}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear equality constraints.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the alternative Lagrangian function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.lag\_alt\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_hessp:cobyqa-optimize-models-lag-alt-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_hessp::doc}}
\sphinxAtStartPar
method
\index{lag\_alt\_hessp() (cobyqa.optimize.Models method)@\spxentry{lag\_alt\_hessp()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_alt_hessp:cobyqa.optimize.Models.lag_alt_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{lag\_alt\_hessp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{lmnlub}}, \emph{\DUrole{n}{lmnleq}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the alternative Lagrangian
function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\item[{\sphinxstylestrong{lmnlub}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear inequality constraints.

\item[{\sphinxstylestrong{lmnleq}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear equality constraints.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the alternative
Lagrangian function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.lag\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_curv:cobyqa-optimize-models-lag-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_curv::doc}}
\sphinxAtStartPar
method
\index{lag\_curv() (cobyqa.optimize.Models method)@\spxentry{lag\_curv()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_curv:cobyqa.optimize.Models.lag_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{lag\_curv}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{lmnlub}}, \emph{\DUrole{n}{lmnleq}}}{}
\sphinxAtStartPar
Evaluate the curvature of the Lagrangian function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{lmnlub}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear inequality constraints.

\item[{\sphinxstylestrong{lmnleq}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear equality constraints.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the Lagrangian function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.lag\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_grad:cobyqa-optimize-models-lag-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_grad::doc}}
\sphinxAtStartPar
method
\index{lag\_grad() (cobyqa.optimize.Models method)@\spxentry{lag\_grad()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_grad:cobyqa.optimize.Models.lag_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{lag\_grad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{lmlub}}, \emph{\DUrole{n}{lmleq}}, \emph{\DUrole{n}{lmnlub}}, \emph{\DUrole{n}{lmnleq}}}{}
\sphinxAtStartPar
Evaluate the gradient of Lagrangian function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{lmlub}}] \leavevmode{[}numpy.ndarray, shape (mlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the linear inequality
constraints.

\item[{\sphinxstylestrong{lmleq}}] \leavevmode{[}numpy.ndarray, shape (mleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the linear equality
constraints.

\item[{\sphinxstylestrong{lmnlub}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear inequality constraints.

\item[{\sphinxstylestrong{lmnleq}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear equality constraints.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the Lagrangian function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.lag\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_hess:cobyqa-optimize-models-lag-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_hess::doc}}
\sphinxAtStartPar
method
\index{lag\_hess() (cobyqa.optimize.Models method)@\spxentry{lag\_hess()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_hess:cobyqa.optimize.Models.lag_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{lag\_hess}}}{\emph{\DUrole{n}{lmnlub}}, \emph{\DUrole{n}{lmnleq}}}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of the Lagrangian function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{lmnlub}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear inequality constraints.

\item[{\sphinxstylestrong{lmnleq}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear equality constraints.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the Lagrangian function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.lag\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_hessp:cobyqa-optimize-models-lag-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_hessp::doc}}
\sphinxAtStartPar
method
\index{lag\_hessp() (cobyqa.optimize.Models method)@\spxentry{lag\_hessp()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.lag_hessp:cobyqa.optimize.Models.lag_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{lag\_hessp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{lmnlub}}, \emph{\DUrole{n}{lmnleq}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the Lagrangian function of
the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\item[{\sphinxstylestrong{lmnlub}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear inequality constraints.

\item[{\sphinxstylestrong{lmnleq}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Lagrange multipliers associated with the quadratic models of the
nonlinear equality constraints.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the Lagrangian
function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.new\_model}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.new_model:cobyqa-optimize-models-new-model}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.new_model::doc}}
\sphinxAtStartPar
method
\index{new\_model() (cobyqa.optimize.Models method)@\spxentry{new\_model()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.new_model:cobyqa.optimize.Models.new_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{new\_model}}}{\emph{\DUrole{n}{val}}}{}
\sphinxAtStartPar
Generate a model obtained by underdetermined interpolation.

\sphinxAtStartPar
The freedom bequeathed by the interpolation conditions defined by \sphinxstyleemphasis{val}
is taken up by minimizing the Hessian matrix of the quadratic function
in Frobenius norm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{val}}] \leavevmode{[}int or numpy.ndarray, shape (npt,){]}
\sphinxAtStartPar
Evaluations associated with the interpolation points. An integer
value represents the \sphinxcode{\sphinxupquote{npt}}\sphinxhyphen{}dimensional vector whose components are
all zero, except the \sphinxstyleemphasis{val}\sphinxhyphen{}th one whose value is one. Hence,
passing an integer value construct the \sphinxstyleemphasis{val}\sphinxhyphen{}th Lagrange polynomial
associated with the interpolation points.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{Quadratic}] \leavevmode
\sphinxAtStartPar
The quadratic model that satisfy the interpolation conditions
defined by \sphinxstyleemphasis{val}, whose Hessian matrix is least in Frobenius norm.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.normalize\_constraints}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.normalize_constraints:cobyqa-optimize-models-normalize-constraints}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.normalize_constraints::doc}}
\sphinxAtStartPar
method
\index{normalize\_constraints() (cobyqa.optimize.Models method)@\spxentry{normalize\_constraints()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.normalize_constraints:cobyqa.optimize.Models.normalize_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{normalize\_constraints}}}{}{}
\sphinxAtStartPar
Normalize the linear constraints.

\sphinxAtStartPar
Each linear inequality and equality constraint is normalized, so that
the Euclidean norm of its gradient is one (if not zero).

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.obj}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj:cobyqa-optimize-models-obj}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj::doc}}
\sphinxAtStartPar
method
\index{obj() (cobyqa.optimize.Models method)@\spxentry{obj()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj:cobyqa.optimize.Models.obj}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{obj}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the objective function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.obj\_alt}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt:cobyqa-optimize-models-obj-alt}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt::doc}}
\sphinxAtStartPar
method
\index{obj\_alt() (cobyqa.optimize.Models method)@\spxentry{obj\_alt()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt:cobyqa.optimize.Models.obj_alt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{obj\_alt}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the alternative objective function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the alternative objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.obj\_alt\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_curv:cobyqa-optimize-models-obj-alt-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_curv::doc}}
\sphinxAtStartPar
method
\index{obj\_alt\_curv() (cobyqa.optimize.Models method)@\spxentry{obj\_alt\_curv()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_curv:cobyqa.optimize.Models.obj_alt_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{obj\_alt\_curv}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the curvature of the alternative objective function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the alternative objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.obj\_alt\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_grad:cobyqa-optimize-models-obj-alt-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_grad::doc}}
\sphinxAtStartPar
method
\index{obj\_alt\_grad() (cobyqa.optimize.Models method)@\spxentry{obj\_alt\_grad()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_grad:cobyqa.optimize.Models.obj_alt_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{obj\_alt\_grad}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the gradient of the alternative objective function of the
model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the alternative objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.obj\_alt\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_hess:cobyqa-optimize-models-obj-alt-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_hess::doc}}
\sphinxAtStartPar
method
\index{obj\_alt\_hess() (cobyqa.optimize.Models method)@\spxentry{obj\_alt\_hess()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_hess:cobyqa.optimize.Models.obj_alt_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{obj\_alt\_hess}}}{}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of the alternative objective function of the
model.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the alternative objective function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.obj\_alt\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_hessp:cobyqa-optimize-models-obj-alt-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_hessp::doc}}
\sphinxAtStartPar
method
\index{obj\_alt\_hessp() (cobyqa.optimize.Models method)@\spxentry{obj\_alt\_hessp()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_alt_hessp:cobyqa.optimize.Models.obj_alt_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{obj\_alt\_hessp}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the alternative objective
function of the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the alternative
objective function of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.obj\_curv}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_curv:cobyqa-optimize-models-obj-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_curv::doc}}
\sphinxAtStartPar
method
\index{obj\_curv() (cobyqa.optimize.Models method)@\spxentry{obj\_curv()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_curv:cobyqa.optimize.Models.obj_curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{obj\_curv}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the curvature of the objective function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.obj\_grad}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_grad:cobyqa-optimize-models-obj-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_grad::doc}}
\sphinxAtStartPar
method
\index{obj\_grad() (cobyqa.optimize.Models method)@\spxentry{obj\_grad()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_grad:cobyqa.optimize.Models.obj_grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{obj\_grad}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the gradient of the objective function of the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Gradient of the objective function of the model at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.obj\_hess}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_hess:cobyqa-optimize-models-obj-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_hess::doc}}
\sphinxAtStartPar
method
\index{obj\_hess() (cobyqa.optimize.Models method)@\spxentry{obj\_hess()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_hess:cobyqa.optimize.Models.obj_hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{obj\_hess}}}{}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of the objective function of the model.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the objective function of the model.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.obj\_hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_hessp:cobyqa-optimize-models-obj-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_hessp::doc}}
\sphinxAtStartPar
method
\index{obj\_hessp() (cobyqa.optimize.Models method)@\spxentry{obj\_hessp()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.obj_hessp:cobyqa.optimize.Models.obj_hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{obj\_hessp}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the objective function of
the model with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the objective function
of the model with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.reset\_models}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.reset_models:cobyqa-optimize-models-reset-models}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.reset_models::doc}}
\sphinxAtStartPar
method
\index{reset\_models() (cobyqa.optimize.Models method)@\spxentry{reset\_models()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.reset_models:cobyqa.optimize.Models.reset_models}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{reset\_models}}}{}{}
\sphinxAtStartPar
Reset the models.

\sphinxAtStartPar
The standard models of the objective function, the nonlinear inequality
constraint function, and the nonlinear equality constraint function are
set to the ones whose Hessian matrices are least in Frobenius norm.

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.resid}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.resid:cobyqa-optimize-models-resid}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.resid::doc}}
\sphinxAtStartPar
method
\index{resid() (cobyqa.optimize.Models method)@\spxentry{resid()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.resid:cobyqa.optimize.Models.resid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{resid}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{cubx}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ceqx}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Evaluate the residual associated with the constraints of the nonlinear
optimization problem.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}int or numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the residual is to be evaluated. An integer value
represents the \sphinxstyleemphasis{x}\sphinxhyphen{}th interpolation point.

\item[{\sphinxstylestrong{cubx}}] \leavevmode{[}numpy.ndarray, shape (mnlub,), optional{]}
\sphinxAtStartPar
Value of the nonlinear inequality constraint function at \sphinxstyleemphasis{x}. It
is required only if \sphinxstyleemphasis{x} is not an integer, and is not considered if
\sphinxstyleemphasis{x} represents an interpolation point.

\item[{\sphinxstylestrong{ceqx}}] \leavevmode{[}numpy.ndarray, shape (mnleq,), optional{]}
\sphinxAtStartPar
Value of the nonlinear equality constraint function at \sphinxstyleemphasis{x}. It is
required only if \sphinxstyleemphasis{x} is not an integer, and is not considered if \sphinxstyleemphasis{x}
represents an interpolation point.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Residual associated with the constraints of the nonlinear
optimization problem at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.shift\_constraints}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.shift_constraints:cobyqa-optimize-models-shift-constraints}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.shift_constraints::doc}}
\sphinxAtStartPar
method
\index{shift\_constraints() (cobyqa.optimize.Models method)@\spxentry{shift\_constraints()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.shift_constraints:cobyqa.optimize.Models.shift_constraints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{shift\_constraints}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Shift the bound and linear constraints.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Coordinates of the shift to be performed.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.shift\_origin}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.shift_origin:cobyqa-optimize-models-shift-origin}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.shift_origin::doc}}
\sphinxAtStartPar
method
\index{shift\_origin() (cobyqa.optimize.Models method)@\spxentry{shift\_origin()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.shift_origin:cobyqa.optimize.Models.shift_origin}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{shift\_origin}}}{}{}
\sphinxAtStartPar
Update the models when the origin of the calculations is modified.
\subsubsection*{Notes}

\sphinxAtStartPar
Given \sphinxcode{\sphinxupquote{xbase}} the previous origin of the calculations, it is assumed
that the origin is shifted by \sphinxcode{\sphinxupquote{xopt}}.

\end{fulllineitems}



\subsection{cobyqa.optimize.Models.update}
\label{\detokenize{refs/generated/cobyqa.optimize.Models.update:cobyqa-optimize-models-update}}\label{\detokenize{refs/generated/cobyqa.optimize.Models.update::doc}}
\sphinxAtStartPar
method
\index{update() (cobyqa.optimize.Models method)@\spxentry{update()}\spxextra{cobyqa.optimize.Models method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Models.update:cobyqa.optimize.Models.update}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Models.}}\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{step}}, \emph{\DUrole{n}{fx}}, \emph{\DUrole{n}{cubx}}, \emph{\DUrole{n}{ceqx}}, \emph{\DUrole{n}{knew}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Update the models of the nonlinear optimization problem when a point of
the interpolation set is modified.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{step}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Displacement from \sphinxcode{\sphinxupquote{xopt}} of the point to replace an interpolation
point.

\item[{\sphinxstylestrong{fx}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Value of the objective function at the trial point.

\item[{\sphinxstylestrong{cubx}}] \leavevmode{[}numpy.ndarray, shape (mnlub,){]}
\sphinxAtStartPar
Value of the nonlinear inequality constraint function at the trial
point.

\item[{\sphinxstylestrong{ceqx}}] \leavevmode{[}numpy.ndarray, shape (mnleq,){]}
\sphinxAtStartPar
Value of the nonlinear equality constraint function at the trial
point.

\item[{\sphinxstylestrong{knew}}] \leavevmode{[}int, optional{]}
\sphinxAtStartPar
Index of the interpolation point to be removed. It is automatically
chosen if it is not provided.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{int}] \leavevmode
\sphinxAtStartPar
Index of the interpolation point that has been replaced.

\end{description}

\item[{Raises}] \leavevmode\begin{description}
\item[{ZeroDivisionError}] \leavevmode
\sphinxAtStartPar
The denominator of the updating formula is zero.

\end{description}

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
When the index \sphinxstyleemphasis{knew} of the interpolation point to be removed is not
provided, it is chosen by the method to maximize the product absolute
value of the denominator in Equation (2.12) of \sphinxcite{refs/generated/cobyqa.optimize.Models.update:rfdf445c32e0f-powe04} with the
quartic power of the distance between the point and \sphinxcode{\sphinxupquote{xopt}}.
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.optimize.Models.update:rfdf445c32e0f-powe04}

\end{fulllineitems}


\end{fulllineitems}



\section{cobyqa.optimize.Quadratic}
\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic:cobyqa-optimize-quadratic}}\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic::doc}}\index{Quadratic (class in cobyqa.optimize)@\spxentry{Quadratic}\spxextra{class in cobyqa.optimize}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic:cobyqa.optimize.Quadratic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{cobyqa.optimize.}}\sphinxbfcode{\sphinxupquote{Quadratic}}}{\emph{\DUrole{n}{bmat}}, \emph{\DUrole{n}{zmat}}, \emph{\DUrole{n}{idz}}, \emph{\DUrole{n}{fval}}}{}
\sphinxAtStartPar
Representation of a quadratic multivariate function.
\subsubsection*{Notes}

\sphinxAtStartPar
To improve the computational efficiency of the updates of the quadratic
functions, the Hessian matrices of a quadratic functions are stored as
explicit and implicit parts, which define the model relatively to the
coordinates of the interpolation points \sphinxcite{refs/generated/cobyqa.optimize.Quadratic:r121380ef860e-powe06}. Initially, the explicit
part of an Hessian matrix is zero and so, is not explicitly stored.
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.optimize.Quadratic:r121380ef860e-powe06}
\begin{quote}\begin{description}
\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxcode{\sphinxupquote{gq}}}] \leavevmode
\sphinxAtStartPar
Stored gradient of the model.

\item[{\sphinxcode{\sphinxupquote{hq}}}] \leavevmode
\sphinxAtStartPar
Stored explicit part of the Hessian matrix of the model.

\item[{\sphinxcode{\sphinxupquote{pq}}}] \leavevmode
\sphinxAtStartPar
Stored implicit part of the Hessian matrix of the model.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic.__call__:cobyqa.optimize.Quadratic.__call__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_call\_\_}}}}}(x, xpt, kopt)
&
\sphinxAtStartPar
Evaluate the quadratic function.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic.check_model:cobyqa.optimize.Quadratic.check_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{check\_model}}}}}(xpt, fval, kopt{[}, stack\_level{]})
&
\sphinxAtStartPar
Check the interpolation conditions.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic.curv:cobyqa.optimize.Quadratic.curv}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{curv}}}}}(x, xpt)
&
\sphinxAtStartPar
Evaluate the curvature of the quadratic function.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic.grad:cobyqa.optimize.Quadratic.grad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{grad}}}}}(x, xpt, kopt)
&
\sphinxAtStartPar
Evaluate the gradient of the quadratic function.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic.hess:cobyqa.optimize.Quadratic.hess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hess}}}}}(xpt)
&
\sphinxAtStartPar
Evaluate the Hessian matrix of the quadratic function.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic.hessp:cobyqa.optimize.Quadratic.hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hessp}}}}}(x, xpt)
&
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the quadratic function with any vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic.shift_expansion_point:cobyqa.optimize.Quadratic.shift_expansion_point}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{shift\_expansion\_point}}}}}(step, xpt)
&
\sphinxAtStartPar
Shift the point around which the quadratic function is defined.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic.shift_interpolation_points:cobyqa.optimize.Quadratic.shift_interpolation_points}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{shift\_interpolation\_points}}}}}(xpt, kopt)
&
\sphinxAtStartPar
Update the components of the quadratic function when the origin from which the interpolation points are defined is to be displaced.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic.update:cobyqa.optimize.Quadratic.update}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update}}}}}(xpt, kopt, xold, bmat, zmat, idz, ...)
&
\sphinxAtStartPar
Update the model when a point of the interpolation set is modified.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsection{cobyqa.optimize.Quadratic.\_\_call\_\_}
\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.__call__:cobyqa-optimize-quadratic-call}}\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.__call__::doc}}
\sphinxAtStartPar
method
\index{\_\_call\_\_() (cobyqa.optimize.Quadratic method)@\spxentry{\_\_call\_\_()}\spxextra{cobyqa.optimize.Quadratic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.__call__:cobyqa.optimize.Quadratic.__call__}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Quadratic.}}\sphinxbfcode{\sphinxupquote{\_\_call\_\_}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{xpt}}, \emph{\DUrole{n}{kopt}}}{}
\sphinxAtStartPar
Evaluate the quadratic function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the quadratic function is to be evaluated.

\item[{\sphinxstylestrong{xpt}}] \leavevmode{[}numpy.ndarray, shape (npt, n){]}
\sphinxAtStartPar
Interpolation points that define the quadratic function. Each row of
\sphinxstyleemphasis{xpt} stores the coordinates of an interpolation point.

\item[{\sphinxstylestrong{kopt}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the interpolation point around which the quadratic function
is defined. The constant term of the quadratic function is not
maintained, and zero is returned at \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}}.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Value of the quadratic function at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Quadratic.check\_model}
\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.check_model:cobyqa-optimize-quadratic-check-model}}\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.check_model::doc}}
\sphinxAtStartPar
method
\index{check\_model() (cobyqa.optimize.Quadratic method)@\spxentry{check\_model()}\spxextra{cobyqa.optimize.Quadratic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.check_model:cobyqa.optimize.Quadratic.check_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Quadratic.}}\sphinxbfcode{\sphinxupquote{check\_model}}}{\emph{\DUrole{n}{xpt}}, \emph{\DUrole{n}{fval}}, \emph{\DUrole{n}{kopt}}, \emph{\DUrole{n}{stack\_level}\DUrole{o}{=}\DUrole{default_value}{2}}}{}
\sphinxAtStartPar
Check the interpolation conditions.

\sphinxAtStartPar
The method checks whether the evaluations of the quadratic function at
the interpolation points match their expected values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{xpt}}] \leavevmode{[}numpy.ndarray, shape (npt, n){]}
\sphinxAtStartPar
Interpolation points that define the quadratic function. Each row of
\sphinxstyleemphasis{xpt} stores the coordinates of an interpolation point.

\item[{\sphinxstylestrong{fval}}] \leavevmode{[}numpy.ndarray, shape (npt,){]}
\sphinxAtStartPar
Evaluations associated with the interpolation points.

\item[{\sphinxstylestrong{kopt}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the interpolation point around which the quadratic function
is defined. The constant term of the quadratic function is not
maintained, and zero is returned at \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}}.

\item[{\sphinxstylestrong{stack\_level}}] \leavevmode{[}int, optional{]}
\sphinxAtStartPar
Stack level of the warning (the default is 2).

\end{description}

\item[{Warns}] \leavevmode\begin{description}
\item[{RuntimeWarning}] \leavevmode
\sphinxAtStartPar
The evaluations of the quadratic function do not satisfy the
interpolation conditions up to a certain tolerance.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Quadratic.curv}
\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.curv:cobyqa-optimize-quadratic-curv}}\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.curv::doc}}
\sphinxAtStartPar
method
\index{curv() (cobyqa.optimize.Quadratic method)@\spxentry{curv()}\spxextra{cobyqa.optimize.Quadratic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.curv:cobyqa.optimize.Quadratic.curv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Quadratic.}}\sphinxbfcode{\sphinxupquote{curv}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{xpt}}}{}
\sphinxAtStartPar
Evaluate the curvature of the quadratic function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the curvature of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{xpt}}] \leavevmode{[}numpy.ndarray, shape (npt, n){]}
\sphinxAtStartPar
Interpolation points that define the quadratic function. Each row of
\sphinxstyleemphasis{xpt} stores the coordinates of an interpolation point.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{float}] \leavevmode
\sphinxAtStartPar
Curvature of the quadratic function at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Although the value can be recovered using {\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic.hessp:cobyqa.optimize.Quadratic.hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hessp}}}}}, the evaluation of
this method improves the computational efficiency.

\end{fulllineitems}



\subsection{cobyqa.optimize.Quadratic.grad}
\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.grad:cobyqa-optimize-quadratic-grad}}\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.grad::doc}}
\sphinxAtStartPar
method
\index{grad() (cobyqa.optimize.Quadratic method)@\spxentry{grad()}\spxextra{cobyqa.optimize.Quadratic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.grad:cobyqa.optimize.Quadratic.grad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Quadratic.}}\sphinxbfcode{\sphinxupquote{grad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{xpt}}, \emph{\DUrole{n}{kopt}}}{}
\sphinxAtStartPar
Evaluate the gradient of the quadratic function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point at which the gradient of the quadratic function is to be
evaluated.

\item[{\sphinxstylestrong{xpt}}] \leavevmode{[}numpy.ndarray, shape (npt, n){]}
\sphinxAtStartPar
Interpolation points that define the quadratic function. Each row of
\sphinxstyleemphasis{xpt} stores the coordinates of an interpolation point.

\item[{\sphinxstylestrong{kopt}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the interpolation point around which the quadratic function
is defined. The constant term of the quadratic function is not
maintained, and zero is returned at \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}}.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the gradient of the quadratic function at \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Quadratic.hess}
\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.hess:cobyqa-optimize-quadratic-hess}}\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.hess::doc}}
\sphinxAtStartPar
method
\index{hess() (cobyqa.optimize.Quadratic method)@\spxentry{hess()}\spxextra{cobyqa.optimize.Quadratic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.hess:cobyqa.optimize.Quadratic.hess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Quadratic.}}\sphinxbfcode{\sphinxupquote{hess}}}{\emph{\DUrole{n}{xpt}}}{}
\sphinxAtStartPar
Evaluate the Hessian matrix of the quadratic function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{xpt}}] \leavevmode{[}numpy.ndarray, shape (npt, n){]}
\sphinxAtStartPar
Interpolation points that define the quadratic function. Each row of
\sphinxstyleemphasis{xpt} stores the coordinates of an interpolation point.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n, n)}] \leavevmode
\sphinxAtStartPar
Hessian matrix of the quadratic function.

\end{description}

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
The Hessian matrix of the model is not explicitly stored and its
computation requires a matrix multiplication. If only products of the
Hessian matrix of the model with any vector are required, consider using
instead {\hyperref[\detokenize{refs/generated/cobyqa.optimize.Quadratic.hessp:cobyqa.optimize.Quadratic.hessp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hessp}}}}}.

\end{fulllineitems}



\subsection{cobyqa.optimize.Quadratic.hessp}
\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.hessp:cobyqa-optimize-quadratic-hessp}}\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.hessp::doc}}
\sphinxAtStartPar
method
\index{hessp() (cobyqa.optimize.Quadratic method)@\spxentry{hessp()}\spxextra{cobyqa.optimize.Quadratic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.hessp:cobyqa.optimize.Quadratic.hessp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Quadratic.}}\sphinxbfcode{\sphinxupquote{hessp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{xpt}}}{}
\sphinxAtStartPar
Evaluate the product of the Hessian matrix of the quadratic function
with any vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Vector to be left\sphinxhyphen{}multiplied by the Hessian matrix of the quadratic
function.

\item[{\sphinxstylestrong{xpt}}] \leavevmode{[}numpy.ndarray, shape (npt, n){]}
\sphinxAtStartPar
Interpolation points that define the quadratic function. Each row of
\sphinxstyleemphasis{xpt} stores the coordinates of an interpolation point.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{numpy.ndarray, shape (n,)}] \leavevmode
\sphinxAtStartPar
Value of the product of the Hessian matrix of the quadratic function
with the vector \sphinxstyleemphasis{x}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Quadratic.shift\_expansion\_point}
\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.shift_expansion_point:cobyqa-optimize-quadratic-shift-expansion-point}}\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.shift_expansion_point::doc}}
\sphinxAtStartPar
method
\index{shift\_expansion\_point() (cobyqa.optimize.Quadratic method)@\spxentry{shift\_expansion\_point()}\spxextra{cobyqa.optimize.Quadratic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.shift_expansion_point:cobyqa.optimize.Quadratic.shift_expansion_point}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Quadratic.}}\sphinxbfcode{\sphinxupquote{shift\_expansion\_point}}}{\emph{\DUrole{n}{step}}, \emph{\DUrole{n}{xpt}}}{}
\sphinxAtStartPar
Shift the point around which the quadratic function is defined.

\sphinxAtStartPar
This method must be called when the index around which the quadratic
function is defined is modified, or when the point in \sphinxstyleemphasis{xpt} around
which the quadratic function is defined is modified.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{step}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Displacement from the current point \sphinxcode{\sphinxupquote{xopt}} around which the
quadratic function is defined. After calling this method, the value
of the quadratic function at \sphinxcode{\sphinxupquote{xopt + step}} is zero, since the
constant term of the function is not maintained.

\item[{\sphinxstylestrong{xpt}}] \leavevmode{[}numpy.ndarray, shape (npt, n){]}
\sphinxAtStartPar
Interpolation points that define the quadratic function. Each row of
\sphinxstyleemphasis{xpt} stores the coordinates of an interpolation point.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{cobyqa.optimize.Quadratic.shift\_interpolation\_points}
\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.shift_interpolation_points:cobyqa-optimize-quadratic-shift-interpolation-points}}\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.shift_interpolation_points::doc}}
\sphinxAtStartPar
method
\index{shift\_interpolation\_points() (cobyqa.optimize.Quadratic method)@\spxentry{shift\_interpolation\_points()}\spxextra{cobyqa.optimize.Quadratic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.shift_interpolation_points:cobyqa.optimize.Quadratic.shift_interpolation_points}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Quadratic.}}\sphinxbfcode{\sphinxupquote{shift\_interpolation\_points}}}{\emph{\DUrole{n}{xpt}}, \emph{\DUrole{n}{kopt}}}{}
\sphinxAtStartPar
Update the components of the quadratic function when the origin from
which the interpolation points are defined is to be displaced.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{xpt}}] \leavevmode{[}numpy.ndarray, shape (npt, n){]}
\sphinxAtStartPar
Interpolation points that define the quadratic function. Each row of
\sphinxstyleemphasis{xpt} stores the coordinates of an interpolation point.

\item[{\sphinxstylestrong{kopt}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the interpolation point around which the quadratic function
is defined. The constant term of the quadratic function is not
maintained, and zero is returned at \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}}.

\end{description}

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Given \sphinxcode{\sphinxupquote{xbase}} the previous origin of the calculations, it is assumed
that the origin is shifted to \sphinxcode{\sphinxupquote{xbase + xpt{[}kopt, :{]}}}.

\end{fulllineitems}



\subsection{cobyqa.optimize.Quadratic.update}
\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.update:cobyqa-optimize-quadratic-update}}\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.update::doc}}
\sphinxAtStartPar
method
\index{update() (cobyqa.optimize.Quadratic method)@\spxentry{update()}\spxextra{cobyqa.optimize.Quadratic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.optimize.Quadratic.update:cobyqa.optimize.Quadratic.update}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{optimize.Quadratic.}}\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{xpt}}, \emph{\DUrole{n}{kopt}}, \emph{\DUrole{n}{xold}}, \emph{\DUrole{n}{bmat}}, \emph{\DUrole{n}{zmat}}, \emph{\DUrole{n}{idz}}, \emph{\DUrole{n}{knew}}, \emph{\DUrole{n}{diff}}}{}
\sphinxAtStartPar
Update the model when a point of the interpolation set is modified.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{xpt}}] \leavevmode{[}numpy.ndarray, shape (npt, n){]}
\sphinxAtStartPar
Interpolation points that define the quadratic function. Each row of
\sphinxstyleemphasis{xpt} stores the coordinates of an interpolation point.

\item[{\sphinxstylestrong{kopt}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the interpolation point around which the quadratic function
is defined. The constant term of the quadratic function is not
maintained, and zero is returned at \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}}.

\item[{\sphinxstylestrong{xold}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Previous point around which the quadratic function was defined.

\item[{\sphinxstylestrong{bmat}}] \leavevmode{[}numpy.ndarray, shape (npt + n, n){]}
\sphinxAtStartPar
Last \sphinxcode{\sphinxupquote{n}} columns of the inverse KKT matrix of interpolation.

\item[{\sphinxstylestrong{zmat}}] \leavevmode{[}numpy.ndarray, shape (npt, npt \sphinxhyphen{} n \sphinxhyphen{} 1){]}
\sphinxAtStartPar
Rank factorization matrix of the leading \sphinxcode{\sphinxupquote{npt}} submatrix of the
inverse KKT matrix of interpolation.

\item[{\sphinxstylestrong{idz}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Number of nonpositive eigenvalues of the leading \sphinxcode{\sphinxupquote{npt}} submatrix
of the inverse KKT matrix of interpolation. Although its theoretical
value is always 0, it is designed to tackle numerical difficulties
caused by ill\sphinxhyphen{}conditioned problems.

\item[{\sphinxstylestrong{knew}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the interpolation point that is modified.

\item[{\sphinxstylestrong{diff}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Difference between the evaluation of the previous model and the
expected value at \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}}.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{refs/linalg:module-cobyqa.linalg}}\index{module@\spxentry{module}!cobyqa.linalg@\spxentry{cobyqa.linalg}}\index{cobyqa.linalg@\spxentry{cobyqa.linalg}!module@\spxentry{module}}

\chapter{Linear algebra (\sphinxstyleliteralintitle{\sphinxupquote{cobyqa.linalg}})}
\label{\detokenize{refs/linalg:linear-algebra-cobyqa-linalg}}\label{\detokenize{refs/linalg::doc}}
\sphinxAtStartPar
This module implements the subproblem solvers of COBYQA. They should be
investigated for specific purposes only, and users who just wish to solve
general derivative\sphinxhyphen{}free optimization problems should instead refer to the
function {\hyperref[\detokenize{refs/generated/cobyqa.minimize:cobyqa.minimize}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cobyqa.minimize}}}}}.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.linalg.bvcs:cobyqa.linalg.bvcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bvcs}}}}}(xpt, kopt, gq, curv, args, xl, xu, ...)
&
\sphinxAtStartPar
Evaluate Cauchy step on the absolute value of a Lagrange polynomial, subject to bound constraints on its coordinates and its length.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.linalg.bvlag:cobyqa.linalg.bvlag}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bvlag}}}}}(xpt, kopt, klag, gq, xl, xu, delta, ...)
&
\sphinxAtStartPar
Estimate a point that maximizes a lower bound on the denominator of the updating formula, subject to bound constraints on its coordinates and its length.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.linalg.bvtcg:cobyqa.linalg.bvtcg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bvtcg}}}}}(xopt, gq, hessp, args, xl, xu, delta, ...)
&
\sphinxAtStartPar
Minimize approximately a quadratic function subject to bound and trust\sphinxhyphen{}region constraints using a truncated conjugate gradient.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.linalg.cpqp:cobyqa.linalg.cpqp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cpqp}}}}}(xopt, Aub, bub, Aeq, beq, xl, xu, ...)
&
\sphinxAtStartPar
Minimize approximately a convex piecewise quadratic function subject to bound and trust\sphinxhyphen{}region constraints using a truncated conjugate gradient.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.linalg.givens:cobyqa.linalg.givens}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{givens}}}}}(M, cval, sval, i, j, axis{[}, slicing{]})
&
\sphinxAtStartPar
Perform a Givens rotation.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.linalg.lctcg:cobyqa.linalg.lctcg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lctcg}}}}}(xopt, gq, hessp, args, Aub, bub, Aeq, ...)
&
\sphinxAtStartPar
Minimize approximately a quadratic function subject to bound, linear, and trust\sphinxhyphen{}region constraints using a truncated conjugate gradient.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.linalg.nnls:cobyqa.linalg.nnls}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nnls}}}}}(A, b{[}, k, maxiter{]})
&
\sphinxAtStartPar
Compute the least\sphinxhyphen{}squares solution of \sphinxcode{\sphinxupquote{A @ x = b}} subject to the nonnegativity constraints \sphinxcode{\sphinxupquote{x{[}:k{]} >= 0}}.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.linalg.qr:cobyqa.linalg.qr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qr}}}}}(a{[}, overwrite\_a, pivoting, check\_finite{]})
&
\sphinxAtStartPar
Compute the QR factorization \sphinxcode{\sphinxupquote{a = Q @ R}} where \sphinxcode{\sphinxupquote{Q}} is an orthogonal matrix and \sphinxcode{\sphinxupquote{R}} is an upper triangular matrix.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\section{cobyqa.linalg.bvcs}
\label{\detokenize{refs/generated/cobyqa.linalg.bvcs:cobyqa-linalg-bvcs}}\label{\detokenize{refs/generated/cobyqa.linalg.bvcs::doc}}\index{linalg.bvcs() (in module cobyqa)@\spxentry{linalg.bvcs()}\spxextra{in module cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.linalg.bvcs:cobyqa.linalg.bvcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{linalg.}}\sphinxbfcode{\sphinxupquote{bvcs}}}{\emph{\DUrole{n}{xpt}}, \emph{\DUrole{n}{kopt}}, \emph{\DUrole{n}{gq}}, \emph{\DUrole{n}{curv}}, \emph{\DUrole{n}{args}}, \emph{\DUrole{n}{xl}}, \emph{\DUrole{n}{xu}}, \emph{\DUrole{n}{delta}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Evaluate Cauchy step on the absolute value of a Lagrange polynomial, subject
to bound constraints on its coordinates and its length.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{xpt}}] \leavevmode{[}numpy.ndarray, shape (npt, n){]}
\sphinxAtStartPar
Set of points. Each row of \sphinxstyleemphasis{xpt} stores the coordinates of a point.

\item[{\sphinxstylestrong{kopt}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the point from which the Cauchy step is evaluated.

\item[{\sphinxstylestrong{gq}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Gradient of the Lagrange polynomial of the points in \sphinxstyleemphasis{xpt} (not
necessarily the \sphinxstyleemphasis{kopt}\sphinxhyphen{}th one) at \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}}.

\item[{\sphinxstylestrong{curv}}] \leavevmode{[}callable{]}
\sphinxAtStartPar
Function providing the curvature of the Lagrange polynomial.
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{curv(x, *args) \sphinxhyphen{}> float}}
\end{quote}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{x}} is an array with shape (n,) and \sphinxcode{\sphinxupquote{args}} is the tuple of
fixed parameters needed to specify the function.

\item[{\sphinxstylestrong{args}}] \leavevmode{[}tuple{]}
\sphinxAtStartPar
Parameters to forward to the curvature function.

\item[{\sphinxstylestrong{xl}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Lower\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{\sphinxhyphen{}numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{xu}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Upper\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{delta}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Upper bound on the length of the Cauchy step.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{step}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Cauchy step.

\item[{\sphinxstylestrong{cauchy}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Square of the Lagrange polynomial evaluation at the Cauchy point.

\end{description}

\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{bdtol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the bound constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * n * max(1, max(abs(xl)), max(abs(xu)))}}.

\end{description}

\item[{Raises}] \leavevmode\begin{description}
\item[{AssertionError}] \leavevmode
\sphinxAtStartPar
The vector \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}} is not feasible.

\end{description}

\end{description}\end{quote}


\sphinxstrong{See also:}
\nopagebreak

\begin{description}
\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.bvlag:cobyqa.linalg.bvlag}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bvlag}}}}}}] \leavevmode
\sphinxAtStartPar
Bounded variable absolute Lagrange polynomial maximization

\end{description}


\subsubsection*{Notes}

\sphinxAtStartPar
The method is adapted from the ALTMOV algorithm \sphinxcite{refs/generated/cobyqa.linalg.bvcs:r2db323da3536-powe09}, and the vector
\sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}} must be feasible.
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.linalg.bvcs:r2db323da3536-powe09}

\end{fulllineitems}



\section{cobyqa.linalg.bvlag}
\label{\detokenize{refs/generated/cobyqa.linalg.bvlag:cobyqa-linalg-bvlag}}\label{\detokenize{refs/generated/cobyqa.linalg.bvlag::doc}}\index{linalg.bvlag() (in module cobyqa)@\spxentry{linalg.bvlag()}\spxextra{in module cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.linalg.bvlag:cobyqa.linalg.bvlag}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{linalg.}}\sphinxbfcode{\sphinxupquote{bvlag}}}{\emph{\DUrole{n}{xpt}}, \emph{\DUrole{n}{kopt}}, \emph{\DUrole{n}{klag}}, \emph{\DUrole{n}{gq}}, \emph{\DUrole{n}{xl}}, \emph{\DUrole{n}{xu}}, \emph{\DUrole{n}{delta}}, \emph{\DUrole{n}{alpha}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Estimate a point that maximizes a lower bound on the denominator of the
updating formula, subject to bound constraints on its coordinates and its
length.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{xpt}}] \leavevmode{[}numpy.ndarray, shape (npt, n){]}
\sphinxAtStartPar
Set of points. Each row of \sphinxstyleemphasis{xpt} stores the coordinates of a point.

\item[{\sphinxstylestrong{kopt}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of a point in \sphinxstyleemphasis{xpt}. The estimated point will lie on a line
joining \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}} to another point in \sphinxstyleemphasis{xpt}.

\item[{\sphinxstylestrong{klag}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Index of the point in \sphinxstyleemphasis{xpt}.

\item[{\sphinxstylestrong{gq}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Gradient of the \sphinxstyleemphasis{klag}\sphinxhyphen{}th Lagrange polynomial at \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}}.

\item[{\sphinxstylestrong{xl}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Lower\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{\sphinxhyphen{}numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{xu}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Upper\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{delta}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Upper bound on the length of the step.

\item[{\sphinxstylestrong{alpha}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Real parameter.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{step}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Step from \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}} towards the estimated point.

\end{description}

\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{bdtol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the bound constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * n * max(1, max(abs(xl)), max(abs(xu)))}}.

\end{description}

\item[{Raises}] \leavevmode\begin{description}
\item[{AssertionError}] \leavevmode
\sphinxAtStartPar
The vector \sphinxcode{\sphinxupquote{xpt{[}kopt, :{]}}} is not feasible.

\end{description}

\end{description}\end{quote}


\sphinxstrong{See also:}
\nopagebreak

\begin{description}
\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.bvcs:cobyqa.linalg.bvcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bvcs}}}}}}] \leavevmode
\sphinxAtStartPar
Bounded variable Cauchy step

\end{description}


\subsubsection*{Notes}

\sphinxAtStartPar
The denominator of the updating formula is given in Equation (3.9) of
\sphinxcite{refs/generated/cobyqa.linalg.bvlag:rebe7aed9360b-powe09}, and the parameter \sphinxstyleemphasis{alpha} is the referred in Equation (4.12) of
\sphinxcite{refs/generated/cobyqa.linalg.bvlag:rebe7aed9360b-powe06}.
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.linalg.bvlag:rebe7aed9360b-powe06}, \sphinxcite{refs/generated/cobyqa.linalg.bvlag:rebe7aed9360b-powe09}

\end{fulllineitems}



\section{cobyqa.linalg.bvtcg}
\label{\detokenize{refs/generated/cobyqa.linalg.bvtcg:cobyqa-linalg-bvtcg}}\label{\detokenize{refs/generated/cobyqa.linalg.bvtcg::doc}}\index{linalg.bvtcg() (in module cobyqa)@\spxentry{linalg.bvtcg()}\spxextra{in module cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.linalg.bvtcg:cobyqa.linalg.bvtcg}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{linalg.}}\sphinxbfcode{\sphinxupquote{bvtcg}}}{\emph{\DUrole{n}{xopt}}, \emph{\DUrole{n}{gq}}, \emph{\DUrole{n}{hessp}}, \emph{\DUrole{n}{args}}, \emph{\DUrole{n}{xl}}, \emph{\DUrole{n}{xu}}, \emph{\DUrole{n}{delta}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Minimize approximately a quadratic function subject to bound and
trust\sphinxhyphen{}region constraints using a truncated conjugate gradient.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{xopt}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point around which the Taylor expansions of the quadratic function is
defined.

\item[{\sphinxstylestrong{gq}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Gradient of the quadratic function at \sphinxstyleemphasis{xopt}.

\item[{\sphinxstylestrong{hessp}}] \leavevmode{[}callable{]}
\sphinxAtStartPar
Function providing the product of the Hessian matrix of the quadratic
function with any vector.
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hessp(x, *args) \sphinxhyphen{}> array\_like, shape(n,)}}
\end{quote}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{x}} is an array with shape (n,) and \sphinxstyleemphasis{args} is a tuple of
parameters to forward to the objective function. It is assumed that the
Hessian matrix implicitly defined by \sphinxstyleemphasis{hessp} is symmetric, but not
necessarily positive semidefinite.

\item[{\sphinxstylestrong{args}}] \leavevmode{[}tuple{]}
\sphinxAtStartPar
Parameters to forward to the Hessian product function.

\item[{\sphinxstylestrong{xl}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Lower\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{\sphinxhyphen{}numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{xu}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Upper\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{delta}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Upper bound on the length of the step from \sphinxstyleemphasis{xopt}.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{step}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Step from \sphinxstyleemphasis{xopt} towards the estimated point.

\end{description}

\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{bdtol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the bound constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * n * max(1, max(abs(xl)), max(abs(xu)))}}.

\end{description}

\item[{Raises}] \leavevmode\begin{description}
\item[{AssertionError}] \leavevmode
\sphinxAtStartPar
The vector \sphinxstyleemphasis{xopt} is not feasible.

\end{description}

\end{description}\end{quote}


\sphinxstrong{See also:}
\nopagebreak

\begin{description}
\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.cpqp:cobyqa.linalg.cpqp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cpqp}}}}}}] \leavevmode
\sphinxAtStartPar
Convex piecewise quadratic programming

\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.lctcg:cobyqa.linalg.lctcg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lctcg}}}}}}] \leavevmode
\sphinxAtStartPar
Linear constrained truncated conjugate gradient

\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.nnls:cobyqa.linalg.nnls}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nnls}}}}}}] \leavevmode
\sphinxAtStartPar
Nonnegative least squares

\end{description}


\subsubsection*{Notes}

\sphinxAtStartPar
The method is adapted from the TRSBOX algorithm \sphinxcite{refs/generated/cobyqa.linalg.bvtcg:r6fcb056338c2-powe09}.
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.linalg.bvtcg:r6fcb056338c2-powe09}

\end{fulllineitems}



\section{cobyqa.linalg.cpqp}
\label{\detokenize{refs/generated/cobyqa.linalg.cpqp:cobyqa-linalg-cpqp}}\label{\detokenize{refs/generated/cobyqa.linalg.cpqp::doc}}\index{linalg.cpqp() (in module cobyqa)@\spxentry{linalg.cpqp()}\spxextra{in module cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.linalg.cpqp:cobyqa.linalg.cpqp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{linalg.}}\sphinxbfcode{\sphinxupquote{cpqp}}}{\emph{\DUrole{n}{xopt}}, \emph{\DUrole{n}{Aub}}, \emph{\DUrole{n}{bub}}, \emph{\DUrole{n}{Aeq}}, \emph{\DUrole{n}{beq}}, \emph{\DUrole{n}{xl}}, \emph{\DUrole{n}{xu}}, \emph{\DUrole{n}{delta}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Minimize approximately a convex piecewise quadratic function subject to
bound and trust\sphinxhyphen{}region constraints using a truncated conjugate gradient.

\sphinxAtStartPar
The method minimizes the function
\begin{equation*}
\begin{split}\frac{1}{2} ( \| [ \mathtt{Aub} \times x - \mathtt{bub} ]_+\|_2^2 +
\| \mathtt{Aeq} \times x - \mathtt{beq} \|_2^2 ),\end{split}
\end{equation*}
\sphinxAtStartPar
where \([ \cdot ]_+\) denotes the componentwise positive part operator.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{xopt}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Center of the trust\sphinxhyphen{}region constraint.

\item[{\sphinxstylestrong{Aub}}] \leavevmode{[}array\_like, shape (mlub, n){]}
\sphinxAtStartPar
Matrix \sphinxstyleemphasis{Aub} as shown above.

\item[{\sphinxstylestrong{bub}}] \leavevmode{[}array\_like, shape (mlub,){]}
\sphinxAtStartPar
Vector \sphinxstyleemphasis{bub} as shown above.

\item[{\sphinxstylestrong{Aeq}}] \leavevmode{[}array\_like, shape (mleq, n){]}
\sphinxAtStartPar
Matrix \sphinxstyleemphasis{Aeq} as shown above.

\item[{\sphinxstylestrong{beq}}] \leavevmode{[}array\_like, shape (meq,){]}
\sphinxAtStartPar
Vector \sphinxstyleemphasis{beq} as shown above.

\item[{\sphinxstylestrong{xl}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Lower\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{\sphinxhyphen{}numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{xu}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Upper\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{delta}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Upper bound on the length of the step from \sphinxstyleemphasis{xopt}.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{step}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Step from \sphinxstyleemphasis{xopt} towards the estimated point.

\end{description}

\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{bdtol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the bound constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * n * max(1, max(abs(xl)), max(abs(xu)))}}.

\end{description}

\item[{Raises}] \leavevmode\begin{description}
\item[{AssertionError}] \leavevmode
\sphinxAtStartPar
The vector \sphinxstyleemphasis{xopt} is not feasible.

\end{description}

\end{description}\end{quote}


\sphinxstrong{See also:}
\nopagebreak

\begin{description}
\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.bvtcg:cobyqa.linalg.bvtcg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bvtcg}}}}}}] \leavevmode
\sphinxAtStartPar
Bounded variable truncated conjugate gradient

\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.lctcg:cobyqa.linalg.lctcg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lctcg}}}}}}] \leavevmode
\sphinxAtStartPar
Linear constrained truncated conjugate gradient

\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.nnls:cobyqa.linalg.nnls}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nnls}}}}}}] \leavevmode
\sphinxAtStartPar
Nonnegative least squares

\end{description}


\subsubsection*{Notes}

\sphinxAtStartPar
The method is adapted from the TRSTEP algorithm \sphinxcite{refs/generated/cobyqa.linalg.cpqp:r5fb36fa06800-powe15}. To cope with the
convex piecewise quadratic objective function, the method minimizes
\begin{equation*}
\begin{split}\frac{1}{2} ( \| \mathtt{Aeq} \times x - \mathtt{beq} \|_2^2 +
\| y \|_2^2 )\end{split}
\end{equation*}
\sphinxAtStartPar
subject to the original constraints, where the slack variable \(y\) is
lower bounded by zero and \(\mathtt{Aub} \times x - \mathtt{bub}\).
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.linalg.cpqp:r5fb36fa06800-powe15}

\end{fulllineitems}



\section{cobyqa.linalg.givens}
\label{\detokenize{refs/generated/cobyqa.linalg.givens:cobyqa-linalg-givens}}\label{\detokenize{refs/generated/cobyqa.linalg.givens::doc}}\index{linalg.givens() (in module cobyqa)@\spxentry{linalg.givens()}\spxextra{in module cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.linalg.givens:cobyqa.linalg.givens}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{linalg.}}\sphinxbfcode{\sphinxupquote{givens}}}{\emph{\DUrole{n}{M}}, \emph{\DUrole{n}{cval}}, \emph{\DUrole{n}{sval}}, \emph{\DUrole{n}{i}}, \emph{\DUrole{n}{j}}, \emph{\DUrole{n}{axis}}, \emph{\DUrole{n}{slicing}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Perform a Givens rotation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{M}}] \leavevmode{[}numpy.ndarray{]}
\sphinxAtStartPar
Matrix on which the Givens rotation is performed in\sphinxhyphen{}place.

\item[{\sphinxstylestrong{cval}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Multiple of the cosine value of the angle of rotation.

\item[{\sphinxstylestrong{sval}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Multiple of the sine value of the angle of rotation.

\item[{\sphinxstylestrong{i}}] \leavevmode{[}int{]}
\sphinxAtStartPar
First index of the Givens rotation procedure.

\item[{\sphinxstylestrong{j}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Second index of the Givens rotation procedure.

\item[{\sphinxstylestrong{axis}}] \leavevmode{[}int{]}
\sphinxAtStartPar
Axis over which to select values. If \sphinxstyleemphasis{M} is a matrix with two
dimensions, the calculations will be applied to the rows by setting
\sphinxcode{\sphinxupquote{axis = 0}} and to the columns by setting \sphinxcode{\sphinxupquote{axis = 1}}.

\item[{\sphinxstylestrong{slicing}}] \leavevmode{[}slice, optional{]}
\sphinxAtStartPar
Part of the data at which the Givens rotation should be applied.
Default applies it to to all the components.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{hval}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Length of the two\sphinxhyphen{}dimensional vector of components \sphinxstyleemphasis{cval} and
\sphinxstyleemphasis{sval}, given by \(\sqrt{ \mathtt{cval}^2 + \mathtt{sval}^2 }\).

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\section{cobyqa.linalg.lctcg}
\label{\detokenize{refs/generated/cobyqa.linalg.lctcg:cobyqa-linalg-lctcg}}\label{\detokenize{refs/generated/cobyqa.linalg.lctcg::doc}}\index{linalg.lctcg() (in module cobyqa)@\spxentry{linalg.lctcg()}\spxextra{in module cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.linalg.lctcg:cobyqa.linalg.lctcg}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{linalg.}}\sphinxbfcode{\sphinxupquote{lctcg}}}{\emph{\DUrole{n}{xopt}}, \emph{\DUrole{n}{gq}}, \emph{\DUrole{n}{hessp}}, \emph{\DUrole{n}{args}}, \emph{\DUrole{n}{Aub}}, \emph{\DUrole{n}{bub}}, \emph{\DUrole{n}{Aeq}}, \emph{\DUrole{n}{beq}}, \emph{\DUrole{n}{xl}}, \emph{\DUrole{n}{xu}}, \emph{\DUrole{n}{delta}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Minimize approximately a quadratic function subject to bound, linear, and
trust\sphinxhyphen{}region constraints using a truncated conjugate gradient.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{xopt}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Point around which the Taylor expansions of the quadratic function is
defined.

\item[{\sphinxstylestrong{gq}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Gradient of the quadratic function at \sphinxstyleemphasis{xopt}.

\item[{\sphinxstylestrong{hessp}}] \leavevmode{[}callable{]}
\sphinxAtStartPar
Function providing the product of the Hessian matrix of the quadratic
function with any vector.
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hessp(x, *args) \sphinxhyphen{}> array\_like, shape(n,)}}
\end{quote}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{x}} is an array with shape (n,) and \sphinxstyleemphasis{args} is a tuple of
parameters to forward to the objective function. It is assumed that the
Hessian matrix implicitly defined by \sphinxstyleemphasis{hessp} is symmetric, but not
necessarily positive semidefinite.

\item[{\sphinxstylestrong{args}}] \leavevmode{[}tuple{]}
\sphinxAtStartPar
Parameters to forward to the Hessian product function.

\item[{\sphinxstylestrong{Aub}}] \leavevmode{[}array\_like, shape (mlub, n), optional{]}
\sphinxAtStartPar
Jacobian matrix of the linear inequality constraints. Each row of \sphinxstyleemphasis{Aub}
stores the gradient of a linear inequality constraint.

\item[{\sphinxstylestrong{bub}}] \leavevmode{[}array\_like, shape (mlub,), optional{]}
\sphinxAtStartPar
Right\sphinxhyphen{}hand side vector of the linear inequality constraints
\sphinxcode{\sphinxupquote{Aub @ x <= bub}}, where \sphinxcode{\sphinxupquote{x}} has the same size than \sphinxstyleemphasis{xopt}.

\item[{\sphinxstylestrong{Aeq}}] \leavevmode{[}array\_like, shape (mleq, n), optional{]}
\sphinxAtStartPar
Jacobian matrix of the linear equality constraints. Each row of \sphinxstyleemphasis{Aeq}
stores the gradient of a linear equality constraint.

\item[{\sphinxstylestrong{beq}}] \leavevmode{[}array\_like, shape (mleq,), optional{]}
\sphinxAtStartPar
Right\sphinxhyphen{}hand side vector of the linear equality constraints
\sphinxstyleemphasis{Aeq @ x = beq}, where \sphinxcode{\sphinxupquote{x}} has the same size than \sphinxstyleemphasis{xopt}.

\item[{\sphinxstylestrong{xl}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Lower\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{\sphinxhyphen{}numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{xu}}] \leavevmode{[}array\_like, shape (n,){]}
\sphinxAtStartPar
Upper\sphinxhyphen{}bound constraints on the decision variables. Use \sphinxcode{\sphinxupquote{numpy.inf}} to
disable the bounds on some variables.

\item[{\sphinxstylestrong{delta}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Upper bound on the length of the step from \sphinxstyleemphasis{xopt}.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{step}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Step from \sphinxstyleemphasis{xopt} towards the estimated point.

\end{description}

\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{bdtol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the bound constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * n * max(1, max(abs(xl)), max(abs(xu)))}}.

\item[{\sphinxstylestrong{lctol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance for comparisons on the linear constraints (the default is
\sphinxcode{\sphinxupquote{10 * eps * max(mlub, n) * max(1, max(abs(bub)))}}).

\end{description}

\item[{Raises}] \leavevmode\begin{description}
\item[{AssertionError}] \leavevmode
\sphinxAtStartPar
The vector \sphinxstyleemphasis{xopt} is not feasible.

\end{description}

\end{description}\end{quote}


\sphinxstrong{See also:}
\nopagebreak

\begin{description}
\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.bvtcg:cobyqa.linalg.bvtcg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bvtcg}}}}}}] \leavevmode
\sphinxAtStartPar
Bounded variable truncated conjugate gradient

\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.cpqp:cobyqa.linalg.cpqp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cpqp}}}}}}] \leavevmode
\sphinxAtStartPar
Convex piecewise quadratic programming

\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.nnls:cobyqa.linalg.nnls}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nnls}}}}}}] \leavevmode
\sphinxAtStartPar
Nonnegative least squares

\end{description}


\subsubsection*{Notes}

\sphinxAtStartPar
The method is adapted from the TRSTEP algorithm \sphinxcite{refs/generated/cobyqa.linalg.lctcg:rc911f6dd4c28-powe15}. It is an
active\sphinxhyphen{}set variation of the truncated conjugate gradient method, which
maintains the QR factorization of the matrix whose columns are the gradients
of the active constraints. The linear equality constraints are then handled
by considering them as always active.
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.linalg.lctcg:rc911f6dd4c28-powe15}

\end{fulllineitems}



\section{cobyqa.linalg.nnls}
\label{\detokenize{refs/generated/cobyqa.linalg.nnls:cobyqa-linalg-nnls}}\label{\detokenize{refs/generated/cobyqa.linalg.nnls::doc}}\index{linalg.nnls() (in module cobyqa)@\spxentry{linalg.nnls()}\spxextra{in module cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.linalg.nnls:cobyqa.linalg.nnls}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{linalg.}}\sphinxbfcode{\sphinxupquote{nnls}}}{\emph{\DUrole{n}{A}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{k}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{maxiter}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Compute the least\sphinxhyphen{}squares solution of \sphinxcode{\sphinxupquote{A @ x = b}} subject to the
nonnegativity constraints \sphinxcode{\sphinxupquote{x{[}:k{]} >= 0}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{A}}] \leavevmode{[}array\_like, shape (m, n){]}
\sphinxAtStartPar
Matrix \sphinxstyleemphasis{A} as shown above.

\item[{\sphinxstylestrong{b}}] \leavevmode{[}array\_like, shape (m,){]}
\sphinxAtStartPar
Right\sphinxhyphen{}hand side vector \sphinxstyleemphasis{b} as shown above.

\item[{\sphinxstylestrong{k}}] \leavevmode{[}int, optional{]}
\sphinxAtStartPar
Number of nonnegativity constraints. The first \sphinxstyleemphasis{k} components of the
solution vector are nonnegative (the default is \sphinxcode{\sphinxupquote{A.shape{[}1{]}}}).

\item[{\sphinxstylestrong{maxiter}}] \leavevmode{[}int, optional{]}
\sphinxAtStartPar
Maximum number of inner iterations (the default is \sphinxcode{\sphinxupquote{3 * A.shape{[}1{]}}}).

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Solution vector \sphinxcode{\sphinxupquote{x}} as shown above.

\item[{\sphinxstylestrong{rnorm}}] \leavevmode{[}float{]}
\sphinxAtStartPar
Residual at the solution.

\end{description}

\item[{Other Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{lstol}}] \leavevmode{[}float, optional{]}
\sphinxAtStartPar
Tolerance on the approximate KKT conditions for the calculations of the
least\sphinxhyphen{}squares Lagrange multipliers (the default is
\sphinxcode{\sphinxupquote{10 * eps * max(n, m) * max(1, max(abs(b)))}}).

\end{description}

\end{description}\end{quote}


\sphinxstrong{See also:}
\nopagebreak

\begin{description}
\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.bvtcg:cobyqa.linalg.bvtcg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bvtcg}}}}}}] \leavevmode
\sphinxAtStartPar
Bounded variable truncated conjugate gradient

\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.cpqp:cobyqa.linalg.cpqp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cpqp}}}}}}] \leavevmode
\sphinxAtStartPar
Convex piecewise quadratic programming

\item[{{\hyperref[\detokenize{refs/generated/cobyqa.linalg.lctcg:cobyqa.linalg.lctcg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lctcg}}}}}}] \leavevmode
\sphinxAtStartPar
Linear constrained truncated conjugate gradient

\end{description}


\subsubsection*{Notes}

\sphinxAtStartPar
The method is adapted from the NNLS algorithm \sphinxcite{refs/generated/cobyqa.linalg.nnls:r345530570369-laha74}.
\subsubsection*{References}

\sphinxAtStartPar
\sphinxcite{refs/generated/cobyqa.linalg.nnls:r345530570369-laha74}

\end{fulllineitems}



\section{cobyqa.linalg.qr}
\label{\detokenize{refs/generated/cobyqa.linalg.qr:cobyqa-linalg-qr}}\label{\detokenize{refs/generated/cobyqa.linalg.qr::doc}}\index{linalg.qr() (in module cobyqa)@\spxentry{linalg.qr()}\spxextra{in module cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.linalg.qr:cobyqa.linalg.qr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{linalg.}}\sphinxbfcode{\sphinxupquote{qr}}}{\emph{\DUrole{n}{a}}, \emph{\DUrole{n}{overwrite\_a}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{pivoting}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{check\_finite}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Compute the QR factorization \sphinxcode{\sphinxupquote{a = Q @ R}} where \sphinxcode{\sphinxupquote{Q}} is an orthogonal
matrix and \sphinxcode{\sphinxupquote{R}} is an upper triangular matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{a}}] \leavevmode{[}array\_like, shape (m, n){]}
\sphinxAtStartPar
Matrix to be factorized.

\item[{\sphinxstylestrong{overwrite\_a}}] \leavevmode{[}bool, optional{]}
\sphinxAtStartPar
Whether to overwrite the data in \sphinxstyleemphasis{a} with the matrix \sphinxcode{\sphinxupquote{R}} (may improve
the performance by limiting the memory cost).

\item[{\sphinxstylestrong{pivoting}}] \leavevmode{[}bool, optional{]}
\sphinxAtStartPar
Whether the factorization should include column pivoting, in which case
a permutation vector \sphinxcode{\sphinxupquote{P}} is returned such that \sphinxcode{\sphinxupquote{A{[}:, P{]} = Q @ R}}.

\item[{\sphinxstylestrong{check\_finite}}] \leavevmode{[}bool, optional{]}
\sphinxAtStartPar
Whether to check that the input matrix contains only finite numbers.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{Q}}] \leavevmode{[}numpy.ndarray, shape (m, m){]}
\sphinxAtStartPar
Above\sphinxhyphen{}mentioned orthogonal matrix \sphinxcode{\sphinxupquote{Q}}.

\item[{\sphinxstylestrong{R}}] \leavevmode{[}numpy.ndarray, shape (m, n){]}
\sphinxAtStartPar
Above\sphinxhyphen{}mentioned upper triangular matrix \sphinxcode{\sphinxupquote{R}}.

\item[{\sphinxstylestrong{P}}] \leavevmode{[}numpy.ndarray, shape (n,){]}
\sphinxAtStartPar
Indices of the permutations. Not returned if \sphinxcode{\sphinxupquote{pivoting=False}}.

\end{description}

\item[{Raises}] \leavevmode\begin{description}
\item[{AssertionError}] \leavevmode
\sphinxAtStartPar
The matrix \sphinxstyleemphasis{a} is not two\sphinxhyphen{}dimensional.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\phantomsection\label{\detokenize{refs/tests:module-cobyqa.tests}}\index{module@\spxentry{module}!cobyqa.tests@\spxentry{cobyqa.tests}}\index{cobyqa.tests@\spxentry{cobyqa.tests}!module@\spxentry{module}}

\chapter{Test support (\sphinxstyleliteralintitle{\sphinxupquote{cobyqa.tests}})}
\label{\detokenize{refs/tests:test-support-cobyqa-tests}}\label{\detokenize{refs/tests::doc}}
\sphinxAtStartPar
This module extends the test support of \sphinxhref{https://numpy.org/doc/stable/reference/routines.testing.html\#module-numpy.testing}{\sphinxcode{\sphinxupquote{numpy.testing}}} to include extra
functions, aiming at simplifying the test scripts of COBYQA.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.tests.assert_array_less_equal:cobyqa.tests.assert_array_less_equal}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{assert\_array\_less\_equal}}}}}(x, y{[}, err\_msg, verbose{]})
&
\sphinxAtStartPar
Raise an AssertionError if two objects are not less\sphinxhyphen{}or\sphinxhyphen{}equal\sphinxhyphen{}ordered.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{refs/generated/cobyqa.tests.assert_dtype_equal:cobyqa.tests.assert_dtype_equal}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{assert\_dtype\_equal}}}}}(actual, desired)
&
\sphinxAtStartPar
Compare the data type of two arrays.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\section{cobyqa.tests.assert\_array\_less\_equal}
\label{\detokenize{refs/generated/cobyqa.tests.assert_array_less_equal:cobyqa-tests-assert-array-less-equal}}\label{\detokenize{refs/generated/cobyqa.tests.assert_array_less_equal::doc}}\index{tests.assert\_array\_less\_equal() (in module cobyqa)@\spxentry{tests.assert\_array\_less\_equal()}\spxextra{in module cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.tests.assert_array_less_equal:cobyqa.tests.assert_array_less_equal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tests.}}\sphinxbfcode{\sphinxupquote{assert\_array\_less\_equal}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{err\_msg}\DUrole{o}{=}\DUrole{default_value}{''}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Raise an AssertionError if two objects are not less\sphinxhyphen{}or\sphinxhyphen{}equal\sphinxhyphen{}ordered.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{x}}] \leavevmode{[}array\_like{]}
\sphinxAtStartPar
Smaller object to check.

\item[{\sphinxstylestrong{y}}] \leavevmode{[}array\_like{]}
\sphinxAtStartPar
Larger object to compare.

\item[{\sphinxstylestrong{err\_msg}}] \leavevmode{[}str, optional{]}
\sphinxAtStartPar
Error message to be printed in case of failure.

\item[{\sphinxstylestrong{verbose}}] \leavevmode{[}bool, optional{]}
\sphinxAtStartPar
Whether the conflicting values are appended to the error message
(default is True).

\end{description}

\item[{Raises}] \leavevmode\begin{description}
\item[{AssertionError}] \leavevmode
\sphinxAtStartPar
The two arrays are not less\sphinxhyphen{}or\sphinxhyphen{}equal\sphinxhyphen{}ordered.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\section{cobyqa.tests.assert\_dtype\_equal}
\label{\detokenize{refs/generated/cobyqa.tests.assert_dtype_equal:cobyqa-tests-assert-dtype-equal}}\label{\detokenize{refs/generated/cobyqa.tests.assert_dtype_equal::doc}}\index{tests.assert\_dtype\_equal() (in module cobyqa)@\spxentry{tests.assert\_dtype\_equal()}\spxextra{in module cobyqa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{refs/generated/cobyqa.tests.assert_dtype_equal:cobyqa.tests.assert_dtype_equal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tests.}}\sphinxbfcode{\sphinxupquote{assert\_dtype\_equal}}}{\emph{\DUrole{n}{actual}}, \emph{\DUrole{n}{desired}}}{}
\sphinxAtStartPar
Compare the data type of two arrays.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{actual}}] \leavevmode{[}array\_like or type{]}
\sphinxAtStartPar
Array obtained.

\item[{\sphinxstylestrong{desired}}] \leavevmode{[}array\_like or type{]}
\sphinxAtStartPar
Array desired.

\end{description}

\item[{Raises}] \leavevmode\begin{description}
\item[{AssertionError}] \leavevmode
\sphinxAtStartPar
The two arrays do not share the same data type.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Reporting bugs}
\label{\detokenize{bugs:reporting-bugs}}\label{\detokenize{bugs::doc}}
\sphinxAtStartPar
To report a bug, request a new feature, or make contributions
(e.g., code patches), please open a new issue on GitHub:
\sphinxurl{https://github.com/ragonneau/cobyqa/issues}.


\chapter{COBYQA license}
\label{\detokenize{license:cobyqa-license}}\label{\detokenize{license::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BSD} \PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{n}{Clause} \PYG{n}{License}

\PYG{n}{Copyright} \PYG{p}{(}\PYG{n}{c}\PYG{p}{)} \PYG{l+m+mi}{2021}\PYG{p}{,} \PYG{n}{Tom} \PYG{n}{M}\PYG{o}{.} \PYG{n}{Ragonneau}
\PYG{n}{All} \PYG{n}{rights} \PYG{n}{reserved}\PYG{o}{.}

\PYG{n}{Redistribution} \PYG{o+ow}{and} \PYG{n}{use} \PYG{o+ow}{in} \PYG{n}{source} \PYG{o+ow}{and} \PYG{n}{binary} \PYG{n}{forms}\PYG{p}{,} \PYG{k}{with} \PYG{o+ow}{or} \PYG{n}{without}
\PYG{n}{modification}\PYG{p}{,} \PYG{n}{are} \PYG{n}{permitted} \PYG{n}{provided} \PYG{n}{that} \PYG{n}{the} \PYG{n}{following} \PYG{n}{conditions} \PYG{n}{are} \PYG{n}{met}\PYG{p}{:}

\PYG{l+m+mf}{1.} \PYG{n}{Redistributions} \PYG{n}{of} \PYG{n}{source} \PYG{n}{code} \PYG{n}{must} \PYG{n}{retain} \PYG{n}{the} \PYG{n}{above} \PYG{n}{copyright} \PYG{n}{notice}\PYG{p}{,} \PYG{n}{this}
   \PYG{n+nb}{list} \PYG{n}{of} \PYG{n}{conditions} \PYG{o+ow}{and} \PYG{n}{the} \PYG{n}{following} \PYG{n}{disclaimer}\PYG{o}{.}

\PYG{l+m+mf}{2.} \PYG{n}{Redistributions} \PYG{o+ow}{in} \PYG{n}{binary} \PYG{n}{form} \PYG{n}{must} \PYG{n}{reproduce} \PYG{n}{the} \PYG{n}{above} \PYG{n}{copyright} \PYG{n}{notice}\PYG{p}{,}
   \PYG{n}{this} \PYG{n+nb}{list} \PYG{n}{of} \PYG{n}{conditions} \PYG{o+ow}{and} \PYG{n}{the} \PYG{n}{following} \PYG{n}{disclaimer} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{documentation}
   \PYG{o+ow}{and}\PYG{o}{/}\PYG{o+ow}{or} \PYG{n}{other} \PYG{n}{materials} \PYG{n}{provided} \PYG{k}{with} \PYG{n}{the} \PYG{n}{distribution}\PYG{o}{.}

\PYG{l+m+mf}{3.} \PYG{n}{Neither} \PYG{n}{the} \PYG{n}{name} \PYG{n}{of} \PYG{n}{the} \PYG{n}{copyright} \PYG{n}{holder} \PYG{n}{nor} \PYG{n}{the} \PYG{n}{names} \PYG{n}{of} \PYG{n}{its}
   \PYG{n}{contributors} \PYG{n}{may} \PYG{n}{be} \PYG{n}{used} \PYG{n}{to} \PYG{n}{endorse} \PYG{o+ow}{or} \PYG{n}{promote} \PYG{n}{products} \PYG{n}{derived} \PYG{k+kn}{from}
   \PYG{n+nn}{this} \PYG{n}{software} \PYG{n}{without} \PYG{n}{specific} \PYG{n}{prior} \PYG{n}{written} \PYG{n}{permission}\PYG{o}{.}

\PYG{n}{THIS} \PYG{n}{SOFTWARE} \PYG{n}{IS} \PYG{n}{PROVIDED} \PYG{n}{BY} \PYG{n}{THE} \PYG{n}{COPYRIGHT} \PYG{n}{HOLDERS} \PYG{n}{AND} \PYG{n}{CONTRIBUTORS} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{AS IS}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{AND} \PYG{n}{ANY} \PYG{n}{EXPRESS} \PYG{n}{OR} \PYG{n}{IMPLIED} \PYG{n}{WARRANTIES}\PYG{p}{,} \PYG{n}{INCLUDING}\PYG{p}{,} \PYG{n}{BUT} \PYG{n}{NOT} \PYG{n}{LIMITED} \PYG{n}{TO}\PYG{p}{,} \PYG{n}{THE}
\PYG{n}{IMPLIED} \PYG{n}{WARRANTIES} \PYG{n}{OF} \PYG{n}{MERCHANTABILITY} \PYG{n}{AND} \PYG{n}{FITNESS} \PYG{n}{FOR} \PYG{n}{A} \PYG{n}{PARTICULAR} \PYG{n}{PURPOSE} \PYG{n}{ARE}
\PYG{n}{DISCLAIMED}\PYG{o}{.} \PYG{n}{IN} \PYG{n}{NO} \PYG{n}{EVENT} \PYG{n}{SHALL} \PYG{n}{THE} \PYG{n}{COPYRIGHT} \PYG{n}{HOLDER} \PYG{n}{OR} \PYG{n}{CONTRIBUTORS} \PYG{n}{BE} \PYG{n}{LIABLE}
\PYG{n}{FOR} \PYG{n}{ANY} \PYG{n}{DIRECT}\PYG{p}{,} \PYG{n}{INDIRECT}\PYG{p}{,} \PYG{n}{INCIDENTAL}\PYG{p}{,} \PYG{n}{SPECIAL}\PYG{p}{,} \PYG{n}{EXEMPLARY}\PYG{p}{,} \PYG{n}{OR} \PYG{n}{CONSEQUENTIAL}
\PYG{n}{DAMAGES} \PYG{p}{(}\PYG{n}{INCLUDING}\PYG{p}{,} \PYG{n}{BUT} \PYG{n}{NOT} \PYG{n}{LIMITED} \PYG{n}{TO}\PYG{p}{,} \PYG{n}{PROCUREMENT} \PYG{n}{OF} \PYG{n}{SUBSTITUTE} \PYG{n}{GOODS} \PYG{n}{OR}
\PYG{n}{SERVICES}\PYG{p}{;} \PYG{n}{LOSS} \PYG{n}{OF} \PYG{n}{USE}\PYG{p}{,} \PYG{n}{DATA}\PYG{p}{,} \PYG{n}{OR} \PYG{n}{PROFITS}\PYG{p}{;} \PYG{n}{OR} \PYG{n}{BUSINESS} \PYG{n}{INTERRUPTION}\PYG{p}{)} \PYG{n}{HOWEVER}
\PYG{n}{CAUSED} \PYG{n}{AND} \PYG{n}{ON} \PYG{n}{ANY} \PYG{n}{THEORY} \PYG{n}{OF} \PYG{n}{LIABILITY}\PYG{p}{,} \PYG{n}{WHETHER} \PYG{n}{IN} \PYG{n}{CONTRACT}\PYG{p}{,} \PYG{n}{STRICT} \PYG{n}{LIABILITY}\PYG{p}{,}
\PYG{n}{OR} \PYG{n}{TORT} \PYG{p}{(}\PYG{n}{INCLUDING} \PYG{n}{NEGLIGENCE} \PYG{n}{OR} \PYG{n}{OTHERWISE}\PYG{p}{)} \PYG{n}{ARISING} \PYG{n}{IN} \PYG{n}{ANY} \PYG{n}{WAY} \PYG{n}{OUT} \PYG{n}{OF} \PYG{n}{THE} \PYG{n}{USE}
\PYG{n}{OF} \PYG{n}{THIS} \PYG{n}{SOFTWARE}\PYG{p}{,} \PYG{n}{EVEN} \PYG{n}{IF} \PYG{n}{ADVISED} \PYG{n}{OF} \PYG{n}{THE} \PYG{n}{POSSIBILITY} \PYG{n}{OF} \PYG{n}{SUCH} \PYG{n}{DAMAGE}\PYG{o}{.}
\end{sphinxVerbatim}

\begin{sphinxthebibliography}{Powe04}
\bibitem[Powe04]{refs/generated/cobyqa.optimize.TrustRegion.model_step:r91f0d0960ad4-powe04}
\sphinxAtStartPar
M. J. D. Powell. “On updating the inverse of a KKT matrix.”
In: Numerical Linear Algebra and Optimization. Ed. by Y. Yuan.
Beijing, CN: Science Press, 2004, pp. 56–78.
\bibitem[Powe94]{refs/generated/cobyqa.optimize.TrustRegion.reduce_penalty_coefficients:r8e0aa6026fda-powe94}
\sphinxAtStartPar
M. J. D. Powell. “A direct search optimization method that
models the objective and constraint functions by linear
interpolation.” In: Advances in Optimization and Numerical Analysis.
Ed. by S. Gomez and J. P. Hennart. Dordrecht, NL: Springer, 1994, pp.
51–67.
\bibitem[CoGT09]{refs/generated/cobyqa.optimize.TrustRegion.trust_region_step:ra296b548e366-cogt09}
\sphinxAtStartPar
A. R. Conn, N. I. M. Gould, and Ph. L. Toint. Trust\sphinxhyphen{}Region
Methods. MPS\sphinxhyphen{}SIAM Ser. Optim. Philadelphia, PA, US: SIAM, 2009.
\bibitem[Powe04]{refs/generated/cobyqa.optimize.Models:ra9ae06802801-powe04}
\sphinxAtStartPar
M. J. D. Powell. “Least Frobenius norm updating of quadratic
models that satisfy interpolation conditions.” In: Math. Program. 100
(2004), pp. 183–215.
\bibitem[Powe04]{refs/generated/cobyqa.optimize.Models.update:rfdf445c32e0f-powe04}
\sphinxAtStartPar
M. J. D. Powell. “On updating the inverse of a KKT matrix.”
In: Numerical Linear Algebra and Optimization. Ed. by Y. Yuan.
Beijing, CN: Science Press, 2004, pp. 56–78.
\bibitem[Powe06]{refs/generated/cobyqa.optimize.Quadratic:r121380ef860e-powe06}
\sphinxAtStartPar
M. J. D. Powell. “The NEWUOA software for unconstrained
optimization without derivatives.” In: Large\sphinxhyphen{}Scale Nonlinear
Optimization. Ed. by G. Di Pillo and M. Roma. New York, NY, US: Springer,
2006, pp. 255–297.
\bibitem[Powe09]{refs/generated/cobyqa.linalg.bvcs:r2db323da3536-powe09}
\sphinxAtStartPar
M. J. D. Powell. The BOBYQA algorithm for bound constrained
optimization without derivatives. Tech. rep. DAMTP 2009/NA06. Cambridge,
UK: Department of Applied Mathematics and Theoretical Physics, University
of Cambridge, 2009.
\bibitem[Powe06]{refs/generated/cobyqa.linalg.bvlag:rebe7aed9360b-powe06}
\sphinxAtStartPar
M. J. D. Powell. “The NEWUOA software for unconstrained
optimization without derivatives.” In: Large\sphinxhyphen{}Scale Nonlinear
Optimization. Ed. by G. Di Pillo and M. Roma. New York, NY, US: Springer,
2006, pp. 255\sphinxhyphen{}–297.
\bibitem[Powe09]{refs/generated/cobyqa.linalg.bvlag:rebe7aed9360b-powe09}
\sphinxAtStartPar
M. J. D. Powell. The BOBYQA algorithm for bound constrained
optimization without derivatives. Tech. rep. DAMTP 2009/NA06. Cambridge,
UK: Department of Applied Mathematics and Theoretical Physics, University
of Cambridge, 2009.
\bibitem[Powe09]{refs/generated/cobyqa.linalg.bvtcg:r6fcb056338c2-powe09}
\sphinxAtStartPar
M. J. D. Powell. The BOBYQA algorithm for bound constrained
optimization without derivatives. Tech. rep. DAMTP 2009/NA06. Cambridge,
UK: Department of Applied Mathematics and Theoretical Physics, University
of Cambridge, 2009.
\bibitem[Powe15]{refs/generated/cobyqa.linalg.cpqp:r5fb36fa06800-powe15}
\sphinxAtStartPar
M. J. D. Powell. “On fast trust region methods for quadratic
models with linear constraints.” In: Math. Program. Comput. 7 (2015), pp.
237–\sphinxhyphen{}267.
\bibitem[Powe15]{refs/generated/cobyqa.linalg.lctcg:rc911f6dd4c28-powe15}
\sphinxAtStartPar
M. J. D. Powell. “On fast trust region methods for quadratic
models with linear constraints.” In: Math. Program. Comput. 7 (2015), pp.
237–267.
\bibitem[LaHa74]{refs/generated/cobyqa.linalg.nnls:r345530570369-laha74}
\sphinxAtStartPar
C. L. Lawson and R. J. Hanson. Solving Least Squares Problems.
Classics Appl. Math. Philadelphia, PA, US: SIAM, 1974.
\end{sphinxthebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{c}
\item\relax\sphinxstyleindexentry{cobyqa}\sphinxstyleindexpageref{refs/optimize:\detokenize{module-cobyqa}}
\item\relax\sphinxstyleindexentry{cobyqa.linalg}\sphinxstyleindexpageref{refs/linalg:\detokenize{module-cobyqa.linalg}}
\item\relax\sphinxstyleindexentry{cobyqa.tests}\sphinxstyleindexpageref{refs/tests:\detokenize{module-cobyqa.tests}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}